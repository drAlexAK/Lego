#pragma config(Sensor, S1,     sDistLeft,      sensorEV3_GenericI2C)
#pragma config(Sensor, S2,     sDistFront,     sensorEV3_GenericI2C)
#pragma config(Sensor, S3,     sDistRight,     sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     sColor,         sensorEV3_Color)
#pragma config(Motor,  motorB,          mWheel,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-irdist.h"

#define INIT_FRONT_DIST_MIN		100
#define INIT_FRONT_DIST_MAX		800
#define INIT_SIDE_DIST_MIN		300
#define INIT_SIDE_DIST_MAx		1500

//------------------------------------------
// wheel
#define WHEEL_DEGREE_MAX 	 	            80
#define WHEEL_ERROR_DEGREE_MIN_IGNORE 	2
#define WHEEL_SPEED_MAX 		            100
#define WHEEL_SPEED_MIN 		            60
// ------------------------------------------
int frontDistMin  = INIT_FRONT_DIST_MIN;
int frontDistMax	= INIT_FRONT_DIST_MAX;
int sideDistMin		= INIT_FRONT_DIST_MIN;
int sideDistMax		= INIT_FRONT_DIST_MAX;

int normalizeSide(int dist);
int normalizeFront(int dist);

int distRight = 0;
int distLeft  = 0;
int distFront = 0;

int kDistFront=0;

task getDist();

task main()
{
	startTask(getDist);
}

task dist()
{
	//int dLeftFront 		= 0;
	//int dRightFront 	= 0;
	//int dLeft 				= 0;
	//int dRight 				= 0;
	int eDistOld      = 0;
	// initialyze IR sensors
	ubyte address = 0x02;
	//string type = MSDISTreadModuleType(sSonarFront, address);

	while ( true)
	{
		//distFront = normalyzeDistFront (SensorValue(sSonarFront));
		//distFront = (normalyzeDistFront (MSDISTreadDist(sSonarFront, address) / 10) );

		// front distance
		kDistFront = (((FRONT_DIST_MAX - FRONT_DIST_MIN) * 100) / (distFront * 100)) * 1.5;

		//readSensor(&muxedSensor[0]);
		//dLeftFront = muxedSensor[0].distance / 10 ; // returns cm

		//readSensor(&muxedSensor[1]);
		//dRightFront = muxedSensor[1].distance / 10 ; // returns cm

		//dLeft  = SensorValue[sSonarLeft];
		//dRight = SensorValue[sSonarRight];

		//dLeftFront	= normalyzeDist(dLeftFront);
		//dRightFront	= normalyzeDist(dRightFront);
		//dLeft 			= normalyzeDist(dLeft);
		//dRight 			= normalyzeDist(dRight);

		eDist = distLeft - distRight; //((2 * dLeft  + 3 * dLeftFront) - (2 * dRight  + 3 * dRightFront)) / 5;
		eDistWidth  = distLeft + distRight;  //((2 * dLeft  + 3 * dLeftFront) + (2 * dRight  + 3 * dRightFront)) / 5;
		if (eDistWidth ==0) eDistWidth = DIST_MAX * 2;

		//eDistFront = dLeftFront - dRightFront;
		eDistSide  = distLeft - distRight;

		eDistOld = eDist;

#ifdef DEBUG_DIST
		displayTextLine(0, "LF: %d", dLeftFront);
		displayTextLine(1, "L :%d", dLeft);
		displayTextLine(2, "RF:%d", dRightFront);
		displayTextLine(3, "R :%d", dRight);
		displayTextLine(4, "F :%d", distFront);
		displayTextLine(5, "eDist:%d", eDist);
#endif
		sleep(25);

	}
}

task wheel()
{
	//int initWheelEncoder = nMotorEncoder[mWheel];
	nMotorEncoder[mWheel] = 0;

	float wheelDegree  = 0.0;
	int wheelDegreeRatio  = 0;
	int wheelDegreeRatioOld = 0;
	int eWheelDegree = 0;
	int mWheelSpeed  = 0;

	float i = 0.0;

	while (true)
	{
		wheelDegreeRatio = ((eDist * 100 / (eDistWidth  )) * WHEEL_DEGREE_MAX) /100 ;
		i = i + eDist * 0.001;
		if (fabs(i) > MAX_I) i = sgn (i) * MAX_I;
		wheelDegree = (wheelDegreeRatio + (wheelDegreeRatio - wheelDegreeRatioOld) * 5) * kDistFront + i ;
		wheelDegreeRatioOld = wheelDegreeRatio;

		if (fabs(wheelDegree) >  WHEEL_DEGREE_MAX ) wheelDegree = sgn(wheelDegree) * WHEEL_DEGREE_MAX; // restrics WHEEL MAX DEGREE
			if ( kDistFront >= FRONT_DIST_MAX )
		{
			if (abs(eDist) < 10) wheelDegree = wheelDegree / 5.0;
			else if (abs(eDist) < 20) wheelDegree = wheelDegree / 3.5;
			else if (abs(eDist) < 30) wheelDegree = wheelDegree / 2.5;
			else if (abs(eDist) < 40) wheelDegree = wheelDegree / 1.75;
			else if (abs(eDist) < 50) wheelDegree = wheelDegree / 1.25;
			else if (abs(eDist) > 80) wheelDegree = wheelDegree * 1.25;
		}

		eWheelDegree = wheelDegree -  nMotorEncoder[mWheel]  ; // calculates error of wheel, degree

		mWheelSpeed = (( eWheelDegree * 100 / WHEEL_DEGREE_MAX) * WHEEL_SPEED_MAX) / 100 * kDistFront ; // calculates while speed
		mWheelSpeed = normalyzeWheelSpeed(mWheelSpeed);
#ifndef DEBUG_WHEEL
		motor[mWheel]  = mWheelSpeed;
#endif

#ifdef DEBUG_WHEEL
		displayTextLine(0, "eDist:%d", eDist);
		displayTextLine(1, "wd :%d", wheelDegree);
		displayTextLine(2, "ewd:%d", eWheelDegree);
		displayTextLine(3, "speed :%d", mWheelSpeed);

#endif

		sleep(25);
	}

}

task getDist(){

	ubyte address = 0x02;

	string type1 = MSDISTreadModuleType(sDistFront, address);
	string type2 = MSDISTreadModuleType(sDistRight, address);
	string type3 = MSDISTreadModuleType(sDistLeft,  address);

	while(true){
		distRight = normalizeSide(MSDISTreadDist(sDistFront, address));
		distLeft  = normalizeSide(MSDISTreadDist(sDistLeft, address));
		distFront = normalizeFront(MSDISTreadDist(sDistRight, address));
		sleep(100);
	}
}

int normalizeFront(int dist){
	if(dist < frontDistMin) return frontDistMin;
	if(dist > frontDistMax) return frontDistMax;
	return dist;
}

int normalizeSide(int dist){
	if(dist < sideDistMin) return sideDistMin;
	if(dist > sideDistMax) return sideDistMax;
	return dist;
}
