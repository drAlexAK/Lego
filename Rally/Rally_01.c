#pragma config(Sensor, S1,     sMUX,           sensorEV3_GenericI2C)
#pragma config(Sensor, S2,     sSonarRight,    sensorSONAR)
#pragma config(Sensor, S3,     sSonarLeft,     sensorSONAR)
#pragma config(Sensor, S4,     sLight,         sensorLightActive)
#pragma config(Motor,  motorA,          mFront,        tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mRear,         tmotorNXT, openLoop, reversed)
#pragma config(Motor,  motorC,          mWheel,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-ev3smux.h"

// defines
//
// distances
#define DIST_MAX 						110
#define DIST_MIN 						10
// wheel
#define WHEEL_DEGREE_MAX 	 	220
#define WHEEL_ERROR_DEGREE_MIN_IGNORE 	20
#define WHEEL_SPEED_MAX 		100
#define WHEEL_SPEED_MIN 		30
// speed
#define SPEED_MAX 					50
#define SPEED_MIN 					50
// debug info
#define DEBUG_DIST
//#define DEBUG_WHEEL
//#define STOP

// headers
//
// calculates distances and error
//
task dist();
//
// restrics MIN and MAX valur of distance
//
int normalyzeDist(int d);
//
// turns the wheel
//
task wheel();
// controls car speed
//
task speed();
//
// restrics MIN and MAX wheel speed value
//
int normalyzeWheelSpeed(int v);
//
// restrics MIN and MAX speed value
//
int normalyzeSpeed(int v);
// variables
//
// error of distance
int eDist = 0;
// error front distance
int eDistFront = 0;
// error side distance
int eDistSide = 0;
// The SMUX can have up to 3 sensors attached to it. Should be GLOBAL variable
tMSEV3 muxedSensor[3];

task main()
{


	startTask(dist);
	startTask(wheel);
	startTask(speed);

	while(true)
	{
		sleep (1000);
	}

}

// controls car speed
//
task speed()
{
	int speed = 0;

	while(true)
	{

		speed = SPEED_MAX - ((abs(eDist) * 100 / (DIST_MAX - DIST_MIN)) * SPEED_MAX / 200);
		speed = normalyzeSpeed(speed);
		motor[mFront] = speed;
		motor[mRear]  = speed;
		sleep(10);
	}

}

// turns the wheel
//
task wheel()
{
	//int initWheelEncoder = nMotorEncoder[mWheel];
	nMotorEncoder[mWheel] = 0;
	int wheelDegree  = 0;
	int eWheelDegree = 0;
	int mWheelSpeed  = 0;
	while (true)
	{

		wheelDegree = ((eDist * 100 / (DIST_MAX - DIST_MIN)) * WHEEL_DEGREE_MAX) /100 ;
		if ( abs(wheelDegree) >  WHEEL_DEGREE_MAX ) wheelDegree = sgn(wheelDegree) * WHEEL_DEGREE_MAX; // restrics WHEEL MAX DEGREE

		eWheelDegree = wheelDegree - nMotorEncoder[mWheel] ; // calculates error of wheel, degree
		if (abs(eWheelDegree) < WHEEL_ERROR_DEGREE_MIN_IGNORE )
		{
			mWheelSpeed = 0;
		}
		else
		{
			mWheelSpeed = (( eWheelDegree * 100 / WHEEL_DEGREE_MAX) * WHEEL_SPEED_MAX) / 100; // calculates while speed
			mWheelSpeed = normalyzeWheelSpeed(mWheelSpeed);
		}
		motor[mWheel]  = mWheelSpeed;

#ifdef DEBUG_WHEEL
		displayTextLine(0, "eDist:%d", eDistance);
		displayTextLine(1, "wd :%d", wheelDegree);
		displayTextLine(2, "ewd:%d", eWheelDegree);
		displayTextLine(3, "speed :%d", mWheelSpeed);

#endif

		sleep(10);
	}

}

//
// calculates distances and error
//
task dist()
{
	int dLeftFront 		= 0;
	int dRightFront 	= 0;
	int dLeft 				= 0;
	int dRight 				= 0;

	initSensor(&muxedSensor[0], msensor_S1_1, sonarCM);
	initSensor(&muxedSensor[1], msensor_S1_2, sonarCM);

	while ( true)
	{
		readSensor(&muxedSensor[0]);
		dLeftFront = muxedSensor[0].distance / 10 ; // returns cm

		readSensor(&muxedSensor[1]);
		dRightFront = muxedSensor[1].distance / 10 ; // returns cm

		dLeft  = SensorValue[sSonarLeft];
		dRight = SensorValue[sSonarRight];

		dLeftFront	= normalyzeDist(dLeftFront);
		dRightFront	= normalyzeDist(dRightFront);
		dLeft 			= normalyzeDist(dLeft);
		dRight 			= normalyzeDist(dRight);

		eDist = ((dLeft * 2 + dLeftFront) - (dRight * 2 + dRightFront)) / 3;
		eDistFront = dLeftFront - dRightFront;
		eDistSide  = dLeft - dRight;


#ifdef DEBUG_DIST
		displayTextLine(0, "LF: %d", dLeftFront);
		displayTextLine(1, "L :%d", dLeft);
		displayTextLine(2, "RF:%d", dRightFront);
		displayTextLine(3, "R :%d", dRight);
		displayTextLine(4, "eDist:%d", eDist);
#endif
		sleep (100);

	}
}

//
// restrics MIN and MAX value of distance
//
int normalyzeDist(int d)
{
	if (d < DIST_MIN) return DIST_MIN;
	if (d > DIST_MAX) return DIST_MAX;
	return d;
}

//
// restrics MIN and MAX wheel speed value
//
int normalyzeWheelSpeed(int v)
{
	if (abs(v) < WHEEL_SPEED_MIN) return sgn(v) * WHEEL_SPEED_MIN; // restrics WHEEL MIN SPEED
	if (abs(v) > WHEEL_SPEED_MAX) return sgn(v) * WHEEL_SPEED_MAX; // restrict WHEEL MAX SPEED
  return v;
}

//
// restrics MIN and MAX speed value
//
int normalyzeSpeed(int v)
{

#ifdef STOP
	return  0;
#endif
	if (v < SPEED_MIN) return SPEED_MIN; // restrics MIN SPEED
  if (v > SPEED_MAX) return SPEED_MAX; // restrict MAX SPEED
	return v;
}
