#pragma config(Sensor, S4,     sFront,         sensorSONAR)
#pragma config(Sensor, S2,     sFrontRight,    sensorI2CCustomFastSkipStates9V))
#pragma config(Motor,  motorA,          mLeft,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mPl,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//
#include "mindsensors-irdist.h"
#include "alex-common.h"
//varieblas
//int vMax = 60;
int vBase = 50;
//int vMin = 0;
int vLeft  = 50;
int vRight = 50;
//
#define DIST_TREE_NORM  		280
#define DIST_HOPE_TREE_MIN  100
#define DIST_FRONT_MIN 			20
#define DEGREES_360_ENC 		4250
#define CM40_ENC 						1950
// the lowest body speed limit
#define M_BODY_SPEED_MIN 15
// the highest body speed limit
#define M_BODY_SPEED_MAX 50

//function
//int getSpeedByFrontDistance();
void findTrees();
int initDistRight();
void goAheadMM(int dist);
void startInit();
void turnRobotDegree(int deg);
int getAngelDeviationDegree(int errorDist, int testLenght);
void robotAngelCalibration(int lenght);
void goToTree(int dist);
int getLimitSpeed(int speedMin, int speedMax, int currentEnc, int targetEnc);
//tasks
task controlMotors();
//

task main()
{
	sleep(7000);
	startTask(controlMotors);
	//turnRobotDegree(90);
	//sleep(3000);
	//turnRobotDegree(360);
	//sleep(3000);
	//turnRobotDegree(180);
	//startInit();
	for(int i =0; i< 5 ; i++){
		robotAngelCalibration(50);
	sleep(1000);
	}

	sleep(1000);
	//findTrees();
	vRight = vLeft = 0;
	stopAllTasks();
}

task controlMotors()
{
	while(1){
		int s =SensorValue(sFront);
		if((s< DIST_FRONT_MIN) && ((vLeft > 0) && (vRight > 0))){
			motor[mLeft] = 0;
			motor[mRight] = 0;
			}else{
			motor[mLeft] = vLeft;
			motor[mRight] = vRight;
		}
	}
}

void findTrees()
{
	int eNorm = initDistRight();
	if (eNorm < DIST_TREE_NORM) eNorm = DIST_TREE_NORM;
	int e =0;
	int u =0;
	int eOld =e;
	int v =0;
	int dist =0;
	int i =0;

	while(true){
		e = eNorm - MSDISTreadDist(sFrontRight);
		while(abs(e) > DIST_HOPE_TREE_MIN){
			i++;
			if(i > 3 ){
				vLeft = vRight = 0;
				playSound(soundBeepBeep);
				sleep(1000);
				dist = MSDISTreadDist(sFrontRight) - DIST_TREE_NORM;
				goToTree(dist);
				return;
			}
			sleep(20);
			e = eNorm - MSDISTreadDist(sFrontRight);
		}
		i = 0;
		u = (e  + ((e - eOld) * 8)) / 4;
		v = vBase - (u * 0.5);
		vLeft = v ;//- u;
		vRight = v ;//+ u;
		eOld = e;
		sleep(20);
	}
}

int initDistRightOld(){
	int d = MSDISTreadDist(sFrontRight);
	int sum =0;
	int attempt = 5;

	for(int i =0; i< attempt; i++){
		sleep(20);
		d = MSDISTreadDist(sFrontRight);
		if (( d > 1000 ) || ( d < 50 )) {
			attempt--;
			sleep(40);
			} else {
			sum += d;
		}
	}
	return sum / attempt;
}

int initDistRight(){
	int d = MSDISTreadDist(sFrontRight);
	const int attempt = 5;
	int a[attempt];

	for(int i =0; i< attempt; i++){
		sleep(20);
		a[i]= MSDISTreadDist(sFrontRight);
	}
	return GetMedian(a, attempt);
}

// if argument is positive angel, robot will turn clockwise, otherwise - anticlockwise.
void turnRobotDegree(int deg){
	nMotorEncoder[mLeft] =0;
	int	enc = (DEGREES_360_ENC * deg) / 360;
	int currentEnc = nMotorEncoder[mLeft];
	int speed = 0 ;
	if(enc > 0){
		while(currentEnc < enc){
			speed = getLimitSpeed(M_BODY_SPEED_MIN, M_BODY_SPEED_MAX, currentEnc, enc);
			vLeft = speed;
			vRight = -1 * speed;
			currentEnc = nMotorEncoder[mLeft];
		}
		} else {
		while(currentEnc > enc){
			speed = getLimitSpeed(M_BODY_SPEED_MIN, M_BODY_SPEED_MAX, currentEnc, enc);
			vLeft = -1 * speed;
			vRight = speed;
			currentEnc = nMotorEncoder[mLeft];
		}
	}
	vLeft = 0;
	vRight = 0;
}

void goAheadMM(int dist){ //MM
	int enc = (CM40_ENC * dist) / 400;
	nMotorEncoder[mLeft] =0;
	int currentEnc = nMotorEncoder[mLeft];
	int speed = 0 ;
	while(currentEnc < enc){
		vLeft = getLimitSpeed(M_BODY_SPEED_MIN, M_BODY_SPEED_MAX, currentEnc, enc);
		vRight = vLeft;
		currentEnc = nMotorEncoder[mLeft];
	}
	vLeft = 0;
	vRight = 0;
}

void startInit(){
	int d = MSDISTreadDist(sFrontRight);
	int i =0;

	for(int k =0; k < 3; k++ ){
		sleep(100);
		d =  MSDISTreadDist(sFrontRight);
		if(d < DIST_TREE_NORM){
			i++;
		}
	}

	if(i == 3){
		turnRobotDegree(-90);
		sleep(1000);
		goAheadMM(DIST_TREE_NORM - abs(d));
		sleep(1000);
		turnRobotDegree(90);
	}
}
// returns degree of diviation by error and lenght distances
int getAngelDeviationDegree(int errorDist, int testLenght){
	return radiansToDegrees( atan2(errorDist, testLenght));
}

void robotAngelCalibration(int lenght){
	int d1 = initDistRight();
	goAheadMM(lenght);
	int d2 = initDistRight();
	int deg = sgn(d2 - d1) * getAngelDeviationDegree(abs(d2 - d1), lenght);//mm
	if (abs(deg) > 3 ) 	turnRobotDegree(deg);
}

void goToTree(int dist){
	turnRobotDegree(sgn(dist) * 90);
	sleep(1000);
	goAheadMM(abs(dist));
	sleep(1000);
	turnRobotDegree(-1 * sgn(dist) * 90);
}

// speed limiter
int getLimitSpeed(const int speedMin, const int speedMax, const int currentEnc, const int targetEnc){
	const int maxEnc = 540;

	if(targetEnc < currentEnc) currentEnc = targetEnc;
	if((currentEnc >= maxEnc) && (currentEnc <= targetEnc - maxEnc)) return speedMax;

	if(targetEnc < (maxEnc * 2)){
		int accel = (speedMax - speedMin) / maxEnc;
		speedMax = ((targetEnc / 2) * accel) + speedMin;
	} else {
		if (currentEnc > maxEnc) currentEnc -= (targetEnc - (maxEnc*2));
		targetEnc = (maxEnc * 2);
	}

	int percentComplete = (currentEnc * 100) / targetEnc;

	if(percentComplete < 50){
		return (speedMin + ((speedMax - speedMin) * percentComplete) / 100);
		}else{
		return (speedMin + (speedMax - speedMin) * (100 - percentComplete) / 100);
	}

}
