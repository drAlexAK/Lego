#pragma config(Sensor, S1,     sDistB1,        sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S2,     sDistB2,        sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S3,     sDistA2,        sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S4,     sDistA1,        sensorI2CCustomFastSkipStates9V)
#pragma config(Motor,  motorA,          mLightA,       tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          mLightB,       tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// includes
//
#include "mindsensors-irdist.h"

// defines
//
#define DEBUG

#define ZONE_A 1
#define ZONE_B -1
//
#define DIST_SHORT     150 		// calculates minimum distance for short distance sensor
#define INTERVAL_SMALL 10     // sleep interval for release car
#define INTERVAL_LONG  20     // sleep interval for new car
//
// light
const int vMaxLight = 40;
const int vMinLight = 5;
const int degreeA   = 145; //170;
const int degreeB   = 145;
// headers
//
task counterA1();
task counterA2();
task counterB1();
task counterB2();
void Switch(int direction);

#ifdef DEBUG
task displayInfo();
#endif

// variables
//
int  qA        = 0;     // queue in the zone A
bool stopLineA = false; // car stops near stop line zone A
int  qB        = 0;     // queue in the zone B
bool stopLineB = false; // car stops near stop line zone B

task main()
{
	int activeZone = ZONE_A;

	startTask(counterA1);
	startTask(counterA2);
	startTask(counterB1);
	startTask(counterB2);

#ifdef DEBUG
	startTask(displayInfo);
#endif
	while(true)
	{
		sleep(100);
		// nNxtButtonPressed 0 = Gray Rectangle button. 1 = Right Arrow button. 2 = Left Arrow button. 3 = Orange Square button.
		if (nNxtButtonPressed == 3) // reset counters
		{
			qA        = 0;     // queue in the zone A
			stopLineA = false; // car stops near stop line zone A7
			qB        = 0;     // queue in the zone B
			stopLineB = false; // car stops near stop line zone B
		}
		int lightDirection = qA - qB ;

		if ((lightDirection > 0) && (activeZone != ZONE_A))
		{
			activeZone = ZONE_A;
			Switch(ZONE_A);
		}
		else if ((lightDirection < 0) && (activeZone != ZONE_B))
		{
			activeZone = ZONE_B;
			Switch(ZONE_B);
		}
	}
}


void Switch(int direction)
{
	nMotorEncoder[mLightA] = 0;
	nMotorEncoder[mLightB] = 0;

	while( (abs(nMotorEncoder[mLightA]) < degreeA ) || ( abs(nMotorEncoder[mLightB]) < degreeB ) ){

		if(abs(nMotorEncoder[mLightA]) >= degreeA)
			motor[mLightA] =0;
		else
			motor[mLightA] = direction * (vMaxLight - ((vMaxLight - vMinLight) * (nMotorEncoder[mLightA] / degreeA))) ;

		if(abs(nMotorEncoder[mLightB]) >= degreeB)
			motor[mLightB] =0;
		else
			motor[mLightB] = (-1 * direction) * (vMaxLight - ((vMaxLight - vMinLight) * (nMotorEncoder[mLightB] / degreeB))) ;
	}
	motor[mLightA] =0;
	motor[mLightB] =0;
}


task counterA1()
{
	int d = 0 ;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistA1, address);
	while(true)
	{
		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistA1, address);
		} while (d  >= DIST_SHORT  | d == -1);

		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistA1, address);
		} while (d  < DIST_SHORT  | d == -1);

		qA++;
	}
}

task counterA2()
{
	int d = 0 ;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistA2, address);
	while(true)
	{
		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistA2, address);
		} while (d  >= DIST_SHORT  | d == -1);

		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistA2, address);
		} while (d  < DIST_SHORT  | d == -1);

		qA--;
	}
}

task counterB1()
{
	int d = 0 ;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistB1, address);
	while(true)
	{
		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistB1, address);
		} while (d  >= DIST_SHORT  | d == -1);

		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistB1, address);
		} while (d  < DIST_SHORT  | d == -1);

		qB++;
	}
}

task counterB2()
{
	int d = 0 ;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistB2, address);
	while(true)
	{
		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistB2, address);
		} while (d  >= DIST_SHORT  | d == -1);

		do
		{
			sleep(INTERVAL_LONG);
			d = MSDISTreadDist(sDistB2, address);
		} while (d  < DIST_SHORT  | d == -1);
		qB--;
	}
}

task displayInfo()
{
	while(true)
	{
		displayTextLine(0,"A %d        ",qA);
		displayTextLine(1,"stopA %d   ",stopLineA);
		displayTextLine(2,"B1 %d        ",qB);
		displayTextLine(3,"stopB %d   ",stopLineB);
		sleep(100);
	}
}
