#pragma config(Sensor, S1,     sCenter,        sensorLightActive)
#pragma config(Sensor, S2,     sLightRight,    sensorI2CCustom9V)
#pragma config(Sensor, S3,     sTouch,         sensorTouch)
#pragma config(Sensor, S4,     sLightLeft,     sensorI2CCustom9V)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

// time: 	09:50 (stable) with accumulator
// motors: 	2
// ger: 	1:1.67

#define RELEASE
//#define DEBUG
//#define SPEEDUP

int getRWRight();
int getRWLeft();
void calibrate ();
void waitTouchRelease();
//-------------------
float KL[8] =  {1.0, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00};  // 0 -> 7 from  black line to edge
//--------------------
int const vCommon = 85;
int vBase 			= vCommon;
int const vMin	= 10;
int const maxI	= 10;
float const k 	= 33;
int iAlert			= 0;
bool leftAlert  = false;
bool rightAlert = false;
//--------------------
#ifdef SPEEDUP
task speedUp()
{
	clearTimer(timer1);
	bool bUp = false;
	while (true)
	{
		if ((bUp == false ) && (time1[timer1] > 3000))
		{
			bUp = true;
			vBase = 100;
			playSound(soundBlip);
		}
		else if (time1[timer1] > 3850)
		{
			vBase = vCommon;
			playSound(soundBlip);
			break;
		}
		sleep(10);
	}

	bUp = false;
	while (true)
	{
		if ((bUp == false ) && (time1[timer1] > 8200))
		{
			bUp = true;
			vBase = 100;
			playSound(soundBlip);
		}
		else if (time1[timer1] > 9050)
		{
			vBase = vCommon;
			playSound(soundBlip);
			bUp = true;
			break;
		}
		sleep(10);
	}
}
#endif
//--------------------
task startUp()
{
	int const vStart   = 30;
	int const tSpeedUp = 350;
	int tSleep = tSpeedUp / ( vCommon - vStart );

	for ( int i = vStart ; i <= vCommon ; i++ )
	{
		vBase = i ;
		sleep(tSleep);
	}
}

//--------------------
task main()
{

	LLinit(sLightLeft); 	// Set up Line Leader sensor type
	LLinit(sLightRight); 	// Set up Line Leader sensor type

	calibrate();
	waitTouchRelease();
	startTask(startUp);
#ifdef SPEEDUP
	startTask(speedUp);
#endif

	int e       		= 0;
	int eOld 				= e;
	int rwLeft  		= getRWLeft();
	int rwRight 		= getRWRight();
	int es 					= rwLeft - rwRight;
	float i 				= 0;
	int 	v 				= 0;
	int   u					= 0;
	int vLeft 			= 0;
	int vRight 			= 0;

	leftAlert  			= false;
	rightAlert 			= false;
	tByteArray rawLightLeft;
	tByteArray rawLightRight;

	while(true)
	{
		//------------
		LLreadSensorRaw(sLightLeft, rawLightLeft);

		rwLeft = 0;
		for(int k = 0; k <= 7 ; k++)
		{
			rwLeft = rwLeft + (rawLightLeft[k] * KL[k]);
		}

		if ((rawLightLeft[7] < 10) && (rawLightLeft[0] > 10)) rwLeft = rwLeft * -1;
		//-----------------
		LLreadSensorRaw(sLightRight, rawLightRight);
		rwRight = 0;
		for(int k = 0; k <= 7; k++)
		{
			rwRight = rwRight + (rawLightRight[k] * KL[7-k]);
		}

		if ((rawLightRight[0] < 10) && (rawLightRight[7] > 10)) rwRight = rwRight  * -1;
		//-------------
		if ((rightAlert == false) && (rawLightLeft[7] < 20) && ((rawLightLeft[1] > 40) || (rawLightLeft[0] > 40))) leftAlert = true;
		if (leftAlert && (iAlert > 0)) leftAlert = ((rawLightLeft[4] > 20) &&
			(rawLightLeft[3] > 20) &&
		(rawLightLeft[2] > 20) &&
		(rawLightLeft[1] > 20) &&
		(rawLightLeft[0] > 20) &&
		(rawLightRight[0] > 20) &&
		(rawLightRight[1] > 20) &&
		(rawLightRight[2] > 20) &&
		(rawLightRight[3] > 20) &&
		(rawLightRight[4] > 20) &&
		(rawLightRight[5] > 20) &&
		(rawLightRight[6] > 20) &&
		(rawLightRight[7] > 20));
		if (leftAlert) rightAlert = false;

		if ((leftAlert == false) && (rawLightRight[0] < 20) && ((rawLightRight[6] > 40) || (rawLightRight[7] > 40))) rightAlert = true;
		if (rightAlert && (iAlert > 0)) rightAlert = ((rawLightRight[3] > 20) &&
			(rawLightRight[4] > 20) &&
		(rawLightRight[5] > 20) &&
		(rawLightRight[6] > 20) &&
		(rawLightRight[7] > 20) &&
		(rawLightLeft[0] > 20) &&
		(rawLightLeft[1] > 20) &&
		(rawLightLeft[2] > 20) &&
		(rawLightLeft[3] > 20) &&
		(rawLightLeft[4] > 20) &&
		(rawLightLeft[5] > 20) &&
		(rawLightLeft[6] > 20) &&
		(rawLightLeft[7] > 20));
		if (rightAlert) leftAlert = false;
		//--------------
		e = rwLeft - rwRight - es;

		if (leftAlert)
		{
			vLeft  = 10;
			vRight = 90 ;
			iAlert ++;
		}
		else if (rightAlert)
		{
			vLeft  = 90;
			vRight = 10;
			iAlert ++;
		}
		else
		{

			if(SensorValue(sCenter) < 25)
				vBase = 100;
			else
				vBase = vCommon;

			i = i + e / 2500;
			if ( fabs(i) > maxI ) i = sgn(i) * maxI ;
			u = (e * 1  + (e - eOld ) * 7) / k + i ;
			v = (vBase - abs (u) * 0.65) ;
			vLeft  = v + u ;
			vRight = v - u ;
			iAlert = 0;
		}

		eOld = e ;

		if (vLeft  < vMin) vLeft  = vMin;
		if (vRight < vMin) vRight = vMin;
		if (vLeft  > 100)  vLeft  = 100;
		if (vRight > 100)  vRight = 100;

#ifdef RELEASE
		motor[mLeft]  = vLeft;
		motor[mRight] = vRight;
#endif
#ifdef DEBUG
		displayVariableValues(0,rwLeft);
		displayVariableValues(1,rwRight);
		displayVariableValues(2,leftAlert);
		displayVariableValues(3,rightAlert);
		displayVariableValues(4,e);
		displayVariableValues(5,u);
		displayVariableValues(6,vLeft);
		displayVariableValues(7, vRight);
#endif
		sleep (1);
		if (SensorValue(sTouch) == 1) break;
	}
	LLsleep(sLightLeft);  // Sleep to conserve power when not in use
	LLsleep(sLightRight); // Sleep to conserve power when not in use
}

//---------------------------------

void calibrate ()
{
	displayBigTextLine(4, "  WHITE");

	while (SensorValue(sTouch) == 0)
	{
		sleep (10);
	}

	while (SensorValue(sTouch) == 1)
	{
		sleep (10);
	}
	LLcalWhite(sLightLeft);
	LLcalWhite(sLightRight);

	playSound(soundBlip);

	displayBigTextLine(4, "   Done");

	sleep(1000);

	displayBigTextLine(4, "  BLACK");

	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}
	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}
	LLcalBlack(sLightLeft);
	LLcalBlack(sLightRight);

	playSound(soundBlip);

	displayBigTextLine(4, "  Done");

	sleep(1000);
}

//-------------------------------

void waitTouchRelease()
{
	displayBigTextLine(4, " START");

	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}

	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}

}
//---------------
int getRWLeft()
{
	tByteArray rawLight;
	LLreadSensorRaw(sLightLeft, rawLight);
	int r = 0;
	for(int k = 0; k <= 7; k++)
	{
		r = r + (rawLight[k] * KL[k]);
	}

	if (( rawLight[7] < 10 ) && ( rawLight[0] > 10 )) r = r * -1;

	return r;
}
//--------------------
int getRWRight()
{
	tByteArray rawLight;
	LLreadSensorRaw(sLightRight, rawLight);

	int r = 0;

	for(int k = 0; k <= 7; k++)
	{
		r = r + (rawLight[k] * KL[7 - k]);
	}

	if (( rawLight[0] < 10 ) && ( rawLight[7] > 10 )) r = r * -1;

	return r;
}
