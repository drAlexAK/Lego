#pragma config(Sensor, S1,     sMUX,           sensorEV3_GenericI2C)
#pragma config(Sensor, S2,     sSonarRight,    sensorSONAR)
#pragma config(Sensor, S3,     sSonarLeft,     sensorSONAR)
#pragma config(Sensor, S4,     sSonarFront,    sensorSONAR)
#pragma config(Motor,  motorA,          mFront,        tmotorNXT, openLoop, reversed)
#pragma config(Motor,  motorB,          mRear,         tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mWheel,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// includes
//
#include "mindsensors-ev3smux.h"

// defines
//
// distances
#define DIST_MAX 						90
#define DIST_MIN 						10
// wheel
#define WHEEL_DEGREE_MAX 	 	200
#define WHEEL_ERROR_DEGREE_MIN_IGNORE 	10
#define WHEEL_SPEED_MAX 		100
#define WHEEL_SPEED_MIN 		60
// speed
#define SPEED_MAX 					100
#define SPEED_MIN 					70
// debug info
#define DEBUG_DIST
//#define DEBUG_WHEEL
//#define STOP
#define FRONT_DIST_MAX        50.0
#define FRONT_DIST_MIN				10.0
//
//
// headers
//
// calculates distances and error
//
task dist();
//
// restrics MIN and MAX valur of distance
//
int normalyzeDist(int d);
//
// turns the wheel
//
task wheel();
// controls car speed
//
task speed();
//
// restrics MIN and MAX wheel speed value
//
int normalyzeWheelSpeed(int v);
//
// restrics MIN and MAX speed value
//
int normalyzeSpeed(int v);
//
// hhghg
//
int normalyzeDistFront(int d);
// variables
//
// error of distance
int eDist = 0;
// error front distance
int distFront = FRONT_DIST_MAX;
int eDistFront = 0;
// error side distance
int eDistSide = 0;
// The SMUX can have up to 3 sensors attached to it. Should be GLOBAL variable
tMSEV3 muxedSensor[3];

task main()
{


	startTask(dist);
	startTask(wheel);
	startTask(speed);

	while(true)
	{
		sleep (1000);
	}

}

// controls car speed
//
task speed()
{
	int speed = 0;
	//int i = 0;

	while(true)
	{
		//i++;
		speed = SPEED_MAX - ((abs(eDist) * 100 / (DIST_MAX - DIST_MIN)) * SPEED_MAX / 150);
		speed = normalyzeSpeed(speed);
		motor[mFront] = speed;
		motor[mRear]  = speed;
		sleep(10);
		//if (i==300)
		//{
		//	motor[mFront] = 0;
		//	motor[mRear]  = 0;
		//	sleep(2000);
		//}
	}

}

// turns the wheel
//
task wheel()
{
	//int initWheelEncoder = nMotorEncoder[mWheel];
	nMotorEncoder[mWheel] = 0;
	int wheelDegree  = 0;
	int wheelDegreeRatio  = 0;
	int wheelDegreeRatioOld = 0;
	int eWheelDegree = 0;
	int mWheelSpeed  = 0;
	float kDistFront = 0;
	while (true)
	{

		wheelDegreeRatio = ((eDist * 100 / (DIST_MAX - DIST_MIN)) * WHEEL_DEGREE_MAX) /100 ;
		// front distance
		kDistFront = (((FRONT_DIST_MAX - FRONT_DIST_MIN) * 100) / (distFront * 100)) * 1;

		wheelDegree = wheelDegreeRatio * kDistFront  + (wheelDegreeRatio - wheelDegreeRatioOld) * 1;
		wheelDegreeRatioOld = wheelDegreeRatio;
		if ( abs(wheelDegree) >  WHEEL_DEGREE_MAX ) wheelDegree = sgn(wheelDegree) * WHEEL_DEGREE_MAX; // restrics WHEEL MAX DEGREE

		eWheelDegree = wheelDegree - nMotorEncoder[mWheel] ; // calculates error of wheel, degree

		if (abs(eWheelDegree) < WHEEL_ERROR_DEGREE_MIN_IGNORE )
		{
			mWheelSpeed = 0;
		}
		else
		{
			mWheelSpeed = (( eWheelDegree * 100 / WHEEL_DEGREE_MAX) * WHEEL_SPEED_MAX) / 100; // calculates while speed
			mWheelSpeed = normalyzeWheelSpeed(mWheelSpeed);
		}

		motor[mWheel]  = mWheelSpeed;

#ifdef DEBUG_WHEEL
		displayTextLine(0, "eDist:%d", eDistance);
		displayTextLine(1, "wd :%d", wheelDegree);
		displayTextLine(2, "ewd:%d", eWheelDegree);
		displayTextLine(3, "speed :%d", mWheelSpeed);

#endif

		sleep(10);
	}

}

//
// calculates distances and error
//
task dist()
{
	int dLeftFront 		= 0;
	int dRightFront 	= 0;
	int dLeft 				= 0;
	int dRight 				= 0;

	initSensor(&muxedSensor[0], msensor_S1_1, sonarCM);
	initSensor(&muxedSensor[1], msensor_S1_2, sonarCM);

	while ( true)
	{
	  distFront = normalyzeDistFront (SensorValue(sSonarFront));

		readSensor(&muxedSensor[0]);
		dLeftFront = muxedSensor[0].distance / 10 ; // returns cm

		readSensor(&muxedSensor[1]);
		dRightFront = muxedSensor[1].distance / 10 ; // returns cm

		dLeft  = SensorValue[sSonarLeft];
		dRight = SensorValue[sSonarRight];

		dLeftFront	= normalyzeDist(dLeftFront);
		dRightFront	= normalyzeDist(dRightFront);
		dLeft 			= normalyzeDist(dLeft);
		dRight 			= normalyzeDist(dRight);

		eDist = ((dLeft  + dLeftFront) - (dRight  + dRightFront)) / 2  ;
		eDistFront = dLeftFront - dRightFront;
		eDistSide  = dLeft - dRight;


#ifdef DEBUG_DIST
		displayTextLine(0, "LF: %d", dLeftFront);
		displayTextLine(1, "L :%d", dLeft);
		displayTextLine(2, "RF:%d", dRightFront);
		displayTextLine(3, "R :%d", dRight);
		displayTextLine(4, "eDist:%d", eDist);
#endif
		sleep (100);

	}
}

//
// restrics MIN and MAX value of distance
//
int normalyzeDistFront(int d)
{
 if (d > FRONT_DIST_MAX) return FRONT_DIST_MAX;
 if (d < FRONT_DIST_MIN) return FRONT_DIST_MIN;
return d;
}

int normalyzeDist(int d)
{
	if (d < DIST_MIN) return DIST_MIN;
	if (d > DIST_MAX) return DIST_MAX;
	return d;
}

//
// restrics MIN and MAX wheel speed value
//
int normalyzeWheelSpeed(int v)
{
	// restrics WHEEL MIN SPEED
	if (abs(v) < WHEEL_SPEED_MIN) return sgn(v) * WHEEL_SPEED_MIN;
	// restrict WHEEL MAX SPEED
	if (abs(v) > WHEEL_SPEED_MAX) return sgn(v) * WHEEL_SPEED_MAX;
	return v;
}

//
// restrics MIN and MAX speed value
//
int normalyzeSpeed(int v)
{

#ifdef STOP
	return  0;
#endif
	// restrics MIN SPEED
	if (v < SPEED_MIN) return SPEED_MIN;
	// restrict MAX SPEED
	if (v > SPEED_MAX) return SPEED_MAX;
	return v;
}
