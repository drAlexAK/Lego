#pragma config(Sensor, S1,     sRight,         sensorLightActive)
#pragma config(Sensor, S2,     sTouch,         sensorEV3_Touch)
#pragma config(Sensor, S3,     sCenter,        sensorEV3_IRSensor)
#pragma config(Sensor, S4,     sLeft,          sensorLightActive)
#pragma config(Motor,  motorC,          mRight,        tmotorEV3_Large, openLoop, reversed, encoder)
#pragma config(Motor,  motorD,          mLeft,         tmotorEV3_Large, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void WaitTouchRelease();
void GetErrorAfterTouchRelease(float &eS);
void ClearAllSensors();

task main()
{
	const int maxSpeed = 100;
	const float ki = 0.02, kp = 2.53, kd = 26.5, maxi = 20;
	float eS = 0, u = 0, eOld = 0, i = 0, e = 0;
	int v = maxSpeed, vLeft = 0, vRight = 0;

	datalogClear();

	ClearAllSensors();
	GetErrorAfterTouchRelease( eS );
	WaitTouchRelease();

	// bMotorReflected[mLeft]=true;
	// bMotorReflected[mRight]=true;
	// bFloatDuringInactiveMotorPWM = false;  //  Brake mode works best for the NXT motors. This is the default mode.
	// bFloatDuringInactiveMotorPWM = true;   // coast or float
	// nMotorPIDSpeedCtrl[mLeft] = mtrNoReg;     // disables motor speed regulation
	// nMotorPIDSpeedCtrl[mRight] = mtrNoReg;
	// nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;  // enables motor speed regulation

	eraseDisplay();

	while (true)
	{
		e = SensorValue (sLeft) - SensorValue (sRight)- eS;

		i = i + ki * e ;
		if ( fabs(i) > maxi ) i = sgn(i) * maxi;
		u = e * kp + (e - eOld) * kd + i;
		//v = maxSpeed - fabs(u) /2;
		v = maxSpeed;

		vLeft = v + u;
		if (vLeft > v) vLeft = v;
		if (vLeft < 0) vLeft = 0;

		vRight = v - u;
		if (vRight > v) vRight = v;
		if (vRight < 0) vRight = 0;

		displayBigTextLine(0, "e: %f", e);
		displayBigTextLine(2, "eOld: %f", eOld);
		displayBigTextLine(4, "u: %f", u);
		displayBigTextLine(6, "vLeft: %d", vLeft);
		displayBigTextLine(8, "vRight: %d", vRight);

		datalogAddValueWithTimeStamp(0, e);
		datalogAddValueWithTimeStamp(1, eOld);
		datalogAddValueWithTimeStamp(2, u);
		datalogAddValueWithTimeStamp(3, i);
		datalogAddValueWithTimeStamp(4, vLeft);
		datalogAddValueWithTimeStamp(5, vRight);

		eOld = e;

		motor[mLeft]  = vLeft;
		motor[mRight] = vRight;

		sleep(10);
		if (SensorValue(sCenter)<25) break ;
		if (SensorValue(sTouch)== 1) break ;
	}
	motor[mLeft]  =0;
	motor[mRight] =0;
}

void WaitTouchRelease ()
{
	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}
	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}

}

void GetErrorAfterTouchRelease(float &eS)
{
	eraseDisplay();
	displayTextLine(1, "Press button to get error.");
	while(SensorValue(sTouch) == 0)
	{
		sleep(10);
	}
	sleep(10);
	displayTextLine(1, "Release button to save.");
	//playSound(soundBeepBeep);
	while(SensorValue(sTouch) == 1)
	{
		eS = SensorValue (sLeft) - SensorValue (sRight);

		displayBigTextLine(2, "Error: %f", eS);

		sleep(10);
	}
}

void ClearAllSensors()
{
	SensorValue (sTouch) =0;
	SensorValue (sLeft)  =0;
	SensorValue (sRight) =0;
}
