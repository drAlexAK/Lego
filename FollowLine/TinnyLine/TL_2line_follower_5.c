#pragma config(Sensor, S1,     sLightRight,    sensorI2CCustom9V)
#pragma config(Sensor, S2,     sCenter1,       sensorLightActive)
#pragma config(Sensor, S3,     sCenter2,       sensorLightActive)
#pragma config(Sensor, S4,     sLightLeft,     sensorI2CCustom9V)
#pragma config(Motor,  motorA,          mRight,        tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mCenter,       tmotorNXT, openLoop, reversed)
#pragma config(Motor,  motorC,          mLeft,         tmotorNXT, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

float GetLFLeft();
float GetLFRight();

#define RELEASE
#define DEBUG

task main()
{

	// init line followers
	LLinit(sLightLeft); 	// Set up Line Leader sensor type
	LLinit(sLightRight); 	// Set up Line Leader sensor type


	// wake up line followers
	LLwakeUp(sLightLeft); 	// Wake sensor from sleep mode
	LLcalWhite(sLightLeft); // Set white threshold for light area
	LLwakeUp(sLightRight); 	// Wake sensor from sleep mode
	LLcalWhite(sLightRight);// Set white threshold for light area
	// -------------------------------------------------------------



	float vMax     = 100;
	float es 			 = 0 ;
	float e 			 = 0;
	float eOld 		 = e;
	float esCenter1 = 0;
	float esCenter2 = 0;
	float eCenter1 = 0;
	float eCenter2 = 0;
	float rwLeft 	 = 0;
	float rwRight  = 0;
	int vLeft      = 0;
	int vRight     = 0;
	int vCenter    = 0;
	float v        = 0;
	float	u			   = 0;
	float	uOld		 = 0;
	float k			   = 15;

	sleep(3000);

	es = GetLFLeft() / k - GetLFRight() / k;
	esCenter1 = SensorValue(sCenter1);
	esCenter2 = SensorValue(sCenter2);

	if (esCenter1 == 0) esCenter1 = 1;
	if (esCenter2 == 0) esCenter2 = 1;

	while(true)
	{

		rwLeft  = GetLFLeft() / k;
		rwRight = GetLFRight()/ k;

		eCenter1 = SensorValue(sCenter1);
		eCenter2 = SensorValue(sCenter2);

		e = rwLeft - rwRight - es;

		u = (e * 1 + (e - eOld ) *  4 )  ;

		if ( u == 0 )
		{
			if (( eCenter1 > 60 ) & ( eCenter2 > 60 ))
			{
#ifdef DEBUG
				playSound(soundBlip);
#endif
				vLeft   = 50 * sgn(uOld) * -1;
				vRight  = 50 * sgn(uOld);
			}

		}
		else
		{
			uOld = u;
			v = vMax - (SensorValue(sCenter1) - esCenter1) / 2 - (SensorValue(sCenter2) - esCenter2) * 1 ;//- abs (u) ;
			//	v = vMax -  / 15 - abs (u) / 1.5;
			vLeft   = v + u ;
			vRight  = v - u ;
			vCenter = u / 1.5;
		}
		eOld = e ;



#ifdef RELEASE
		motor[mLeft]   = vLeft;
		motor[mRight]  = vRight;
		//motor[mCenter] = vCenter;
#endif
#ifdef DEBUG
		displayVariableValues(0,rwLeft);
		displayVariableValues(1,rwRight);
		displayVariableValues(2,u);
		displayVariableValues(3,v);
		displayVariableValues(4,vLeft);
		displayVariableValues(5,vRight);
		displayVariableValues(6,vCenter);
#endif

	}
	LLsleep(sLightLeft); // Sleep to conserve power when not in use
	LLsleep(sLightRight); // Sleep to conserve power when not in use

}

float GetLFLeft()
{
	tByteArray rawLight;

	LLreadSensorRaw(sLightLeft, rawLight); // read the raw sensor data (8 bit data)
	return
	(
	rawLight[0] * 1.00 +
	rawLight[1] * 1.05 +
	rawLight[2] * 1.10 +
	rawLight[3] * 1.20 +
	rawLight[4] * 1.30 +
	rawLight[5] * 1.50 +
	rawLight[6] * 2.00 +
	rawLight[7] * 3
	);
}
float GetLFRight()
{
	tByteArray rawLight;
	LLreadSensorRaw(sLightRight, rawLight); // read the raw sensor data (8 bit data)
	return
	(
	rawLight[0] * 3.00 +
	rawLight[1] * 2.00 +
	rawLight[2] * 1.50 +
	rawLight[3] * 1.30 +
	rawLight[4] * 1.20 +
	rawLight[5] * 1.10 +
	rawLight[6] * 1.05 +
	rawLight[7] * 1.00
	);
}
