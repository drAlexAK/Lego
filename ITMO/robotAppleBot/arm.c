#pragma config(Motor,  motorA,          mRotation,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mArm,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          mLandle,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "alex-common.h"
#include "shared.h"
#include "nxtPipe.h"
//----------------------------
//
//#define DEBUG
//
#define DEGREES_360_ROTATION_ENC 2100
#define ROTATION_MAX_360_DEGREE   360
#define M_ROTATION_SPEED_MIN      20
#define M_ROTATION_SPEED_MAX      100
#define ARM_270MM_ENCODER 				9500
#define ARM_MAX_POSITION_270MM    270
#define M_ARM_SPEED_MIN           20
#define M_ARM_SPEED_MAX           100
#define LANDLE_11000_ENCODER      2500 // 11000
#define M_LANDLE_SPEED_MIN        10
#define M_LANDLE_SPEED_MAX        100
//----------------------------

//----------------------------
void rotatePlatform(int deg);
void upArmMM(int posit);
void upLandle(bool up);
void Parking();
task ParkingArm();
task ParkingRotation();
task ParkingLandle();
//----------------------------
int  CurrentPositionArmEnc 			= 0;
int  CurrentPositionRotationEnc = 0;
bool CurrentPositionLandle 			= true;
//----------------------------

task main()
{

	sleep(3000);

	//rotatePlatform(-180);
	//rotatePlatform(0);
	//rotatePlatform(180);

	upLandle(false);
	sleep(3000);
	//upArmMM(70);
#ifdef DEBUG
	sleep(300);
#endif
	//upArmMM(180);
#ifdef DEBUG
	sleep(300);
#endif
	//upArmMM(0);
#ifdef DEBUG
	sleep(300);
#endif
	//upArmMM(120);
	//upLandle(true);
#ifdef DEBUG
	sleep(300);
#endif
	//rotatePlatform(180);

	Parking();

	stopAllTasks();
}

void Parking(){
	startTask(ParkingArm);
	startTask(ParkingRotation);
	startTask(ParkingLandle);
	while((CurrentPositionArmEnc != 0) ||
		(CurrentPositionRotationEnc != 0) ||
	(CurrentPositionLandle != true)){
		sleep(100);
	}
}

task ParkingArm(){
	upArmMM(0);
}
task ParkingRotation(){
	rotatePlatform(0);
}
task ParkingLandle(){
	upLandle(true);
}

void upLandle(bool up)
{
	if (CurrentPositionLandle == up) return;
	nMotorEncoder[mLandle] =0;
	int	enc = up ? (LANDLE_11000_ENCODER) : (-1 * LANDLE_11000_ENCODER) ;
	int currentEnc = nMotorEncoder[mLandle];
	int speed = 0 ;
	if(up){
		while(currentEnc < enc){
			speed = getLimitSpeed(M_LANDLE_SPEED_MIN, M_LANDLE_SPEED_MAX, currentEnc, enc);
			motor[mLandle] = speed;
			currentEnc = nMotorEncoder[mLandle];
		}
		} else {
		while(currentEnc > enc){
			speed = getLimitSpeed(M_LANDLE_SPEED_MIN, M_LANDLE_SPEED_MAX, currentEnc, enc);
			motor[mLandle]= -1 * speed;
			currentEnc = nMotorEncoder[mLandle];
		}
	}
	motor[mLandle]=0;
	CurrentPositionLandle = up;
}

void upArmMM(int posit){
	if (posit<0) posit = 0;
	if (posit>ARM_MAX_POSITION_270MM) posit = ARM_MAX_POSITION_270MM;
	nMotorEncoder[mArm] =0;
	int	enc = (ARM_270MM_ENCODER * posit) / ARM_MAX_POSITION_270MM - CurrentPositionArmEnc;

	int currentEnc = nMotorEncoder[mArm];
	int speed = 0 ;
	if(enc > 0){
		while(currentEnc < enc){
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
			motor[mArm] = speed;
			currentEnc = nMotorEncoder[mArm];
		}
		} else {
		while(currentEnc > enc){
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
			motor[mArm]= -1 * speed;
			currentEnc = nMotorEncoder[mArm];
		}
	}
	motor[mArm]=0;
	CurrentPositionArmEnc +=  nMotorEncoder[mArm];
}

void rotatePlatform(int deg){
	if (abs(deg) > ROTATION_MAX_360_DEGREE) deg = sgn(deg) * ROTATION_MAX_360_DEGREE;
	nMotorEncoder[mRotation] =0;
	int	enc = (DEGREES_360_ROTATION_ENC * deg) / ROTATION_MAX_360_DEGREE - CurrentPositionRotationEnc;
	int currentEnc = nMotorEncoder[mRotation];
	int speed = 0 ;
	if(enc > 0){
		while(currentEnc < enc){
			speed = getLimitSpeed(M_ROTATION_SPEED_MIN, M_ROTATION_SPEED_MAX, currentEnc, enc);
			motor[mRotation] = speed;
			currentEnc = nMotorEncoder[mRotation];
		}
		} else {
		while(currentEnc > enc){
			speed = getLimitSpeed(M_ROTATION_SPEED_MIN, M_ROTATION_SPEED_MAX, currentEnc, enc);
			motor[mRotation]= -1 * speed;
			currentEnc = nMotorEncoder[mRotation];
		}
	}
	motor[mRotation]=0;
	CurrentPositionRotationEnc += nMotorEncoder[mRotation];
}
