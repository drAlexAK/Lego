#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          motorZA,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorZB,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task mA();

const int vMaxLight = 40;
const int vMinLight = 5;
const int degreeA = 145;//170;
const int degreeB = 145;

int direction = 1;

task main()
{
	int i = 0 ;
	while(true){
		i++;
		if (i>=100) break;
		/*	nMotorEncoder[motorZA] =0;
		motor[motorZA] = vMaxLight;
		motor[motorZB] = vMaxLight;

		while(nMotorEncoder[motorZA] <= degree){

		motor[motorZB] = vMaxLight - ((vMaxLight - vMinLight) * (nMotorEncoder[motorZA] / degree));
		}

		motor[motorZB] =0;
		sleep(5000);*/
		direction = direction * -1;
		startTask(mA);
		sleep(500);
	}
}
task mA()
{

	nMotorEncoder[motorZA] = 0;
	nMotorEncoder[motorZB] = 0;

	while( (abs(nMotorEncoder[motorZA]) < degreeA ) || ( abs(nMotorEncoder[motorZB]) < degreeB ) ){

		if(abs(nMotorEncoder[motorZA]) >= degreeA)
			motor[motorZA] =0;
		else
			motor[motorZA] = direction * (vMaxLight - ((vMaxLight - vMinLight) * (nMotorEncoder[motorZA] / degreeA))) ;

		if(abs(nMotorEncoder[motorZB]) >= degreeB)
			motor[motorZB] =0;
		else
			motor[motorZB] = (-1 * direction) * (vMaxLight - ((vMaxLight - vMinLight) * (nMotorEncoder[motorZB] / degreeB))) ;
	}
	motor[motorZA] =0;
	motor[motorZB] =0;
}
