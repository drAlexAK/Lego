#pragma config(Sensor, S1,     sLightLeft,     sensorLightActive)
#pragma config(Sensor, S2,     sLightRight,    sensorLightActive)
#pragma config(Sensor, S4,     sTouch,         sensorEV3_Touch)
#pragma config(Motor,  motorA,          mCenter,       tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          mRight,        tmotorEV3_Large, openLoop, reversed, encoder)
#pragma config(Motor,  motorD,          mLeft,         tmotorEV3_Large, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
//
// struct
typedef struct{
	int left;
	int right;
	int center;
} LightSensors;
//
//
// headers
//
void getLightSensorsValuesByTouch(string *areaDecription, LightSensors &ls);
void WaitTouchSensor();
void ResetLightsSensors();

task main()
{
	bMotorReflected[motorC]=true;
	bMotorReflected[motorD]=true;
	//bFloatDuringInactiveMotorPWM = false;  //  Brake mode works best for the NXT motors. This is the default mode.
	bFloatDuringInactiveMotorPWM = true;   // coast or float
	nMotorPIDSpeedCtrl[mLeft] = mtrNoReg;     // disables motor speed regulation
	nMotorPIDSpeedCtrl[mRight] = mtrNoReg;
	//nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;  // enables motor speed regulation

	LightSensors lsWhite;

	datalogClear();

	getLightSensorsValuesByTouch("white", lsWhite);
	ResetLightsSensors();

	SensorValue[mCenter] = 0; // reset center motor

	WaitTouchSensor();
	eraseDisplay();

	const int vMax = 100;
	int es = lsWhite.left - lsWhite.right; // error static, different beetwen left and right light sensors at start
	int eOld = es;
	int v = vMax, vLeft=0, vRight=0; // speed
	int sLeft = 0 , sRight = 0; // light sensors value
	int e=0, u =0;

	while(true)
	{
		sLeft  = SensorValue(sLightLeft);
		sRight = SensorValue(sLightRight);

		e = sLeft - sRight - es;

		//if (sgn(e) != sgn(eOld)) eOld = e ; //drop eOld

		// the best time 8, 33% - fals

		//eOld = e ; // debug only
		u = ( e + ( e - eOld) * 10) * 2;

		v = vMax - abs(u);
		vLeft = v + u;
		vRight = v - u;

		if (abs(vLeft) > vMax) vLeft = sgn(vLeft) * vMax;
		if (abs(vRight) > vMax) vRight = sgn(vRight) * vMax;
/*
		datalogAddValueWithTimeStamp(0, e);
		datalogAddValueWithTimeStamp(1, eOld);
		datalogAddValueWithTimeStamp(2, u);
		datalogAddValueWithTimeStamp(3, v);
		datalogAddValueWithTimeStamp(4, v+u);
		datalogAddValueWithTimeStamp(5, v-u);
*/
		displayCenteredTextLine(1, "e\t%d", e);
		displayCenteredTextLine(2, "u\t%d", u);
		displayCenteredTextLine(3, "vRight\t%d", vRight);
		displayCenteredTextLine(4, "vLeft\t%d", vLeft);

		eOld = e;
		//int wh = -1 * e;
		//if (abs(wh)>50) wh=sgn(e)*-50;
		//while(( nMotorEncoder[mCenter] - wh ) != 0 )
		//{
		//	int sgnWh = sgn( nMotorEncoder[mCenter]-wh);
		//	if (sgnWh==0) break;
		//	motor[mCenter] = sgnWh * -10 * (abs(nMotorEncoder[mCenter] - wh)/10+0.75);
		//}
		motor[mCenter] = 0;

		motor[mLeft] = vLeft;
		motor[mRight] = vRight;

		wait1Msec(50);
		if (SensorValue(sTouch) == 1)	break;

	}

	return ;

	int i=1;
	int j=1;


	while (true)
	{
		j=j + 1;
		if (j>10) break;
		i = i * -1;
		if (i >0)
		{
			while(nMotorEncoder[mCenter] < (55 * i))
			{
				motor[mCenter] = 100 * i;
			}
		}
		else
		{
			while(nMotorEncoder[mCenter] > (55 * i))
			{
				motor[mCenter] = 100 * i;
				sleep(1);
			}
		}
		motor[mCenter] = 0;
		sleep(1000);
	}
	motor[mCenter] = 0;
	motor[mLeft] = 0;
	motor[mRight] = 0;

}


//
// Reset sensors value
//
void ResetLightsSensors()
{
	SensorValue(sLightLeft)=0;
	SensorValue(sLightRight)=0;
	sensorReset(sLightLeft);
	sensorReset(sLightRight);
	//SensorValue(sLightCenter)=0;
}

///////
//
// waits touch sensonr and
//
void WaitTouchSensor()
{
	eraseDisplay();
	displayCenteredTextLine(1, "Stay on the line");
	displayCenteredTextLine(2, "press button");

	while(SensorValue(sTouch) == 0)
	{
		wait1Msec(10);
	}
	eraseDisplay();  // erase the entire NXT LCD display
	displayCenteredTextLine(1, "Stay on the line");
	displayCenteredTextLine(2, "release button");
	displayCenteredTextLine(3, "to start");

	while(SensorValue(sTouch) == 1)
	{
		wait1Msec(1);
	}
}

///////
//
// waits touch sensor and
// returns light sensors values
//
void getLightSensorsValuesByTouch(string *areaDecription, LightSensors &ls)
{
	eraseDisplay(); // cleans NXT display
	displayCenteredTextLine(1, "Stay at %s area", areaDecription);
	displayCenteredTextLine(2, "press button");

	while(SensorValue(sTouch) == 0)
	{
		wait1Msec(10);
	}

	eraseDisplay();  // erase the entire NXT LCD display
	displayCenteredTextLine(1, "Stay at %s area", areaDecription);
	displayCenteredTextLine(2, "release button");
	displayCenteredTextLine(3, "to save values");

	while(SensorValue(sTouch) == 1)
	{
		ls.left=SensorValue(sLightLeft);
		ls.right=SensorValue(sLightRight);
		//ls.center=SensorValue(sLightCenter);

		displayCenteredTextLine(4, "Left:   %d", ls.left);
		displayCenteredTextLine(5, "Right:  %d", ls.right);
		displayCenteredTextLine(6, "Center: %d", ls.center);
		displayCenteredTextLine(7, "Diff:   %d", ls.left - ls.right);

		wait1Msec(10);
	}
	playSound(soundBeepBeep);
	sleep(100);
}
