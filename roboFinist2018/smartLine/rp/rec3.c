#pragma config(Sensor, S4,     sLightLeft,     sensorI2CCustom9V)
#pragma config(Sensor, S1,     sLightRight,    sensorI2CCustom9V)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

// time: 	    08:20 - 08:40 (left) 8:60 - 8:80 (right) fast
// direction: left
// motors: 	  2
// ger: 	    direct
// tire:      \__/ #61481 + #56145c04

#define RELEASE
//#define DEBUG
//--------------------
typedef struct power{
	byte left;
	byte right;
}power;

typedef enum MODE {
	MODE_REC  = 1,
	MODE_PLAY =2
} MODE;

//--------------------
MODE getMode();
MODE revertMode(MODE mode);
int getRWRight(tByteArray rawLight);
int getRWLeft(tByteArray rawLight);
void calibrate ();
void waitTouchRelease();
void safeToFile(power *p, int size);
//--------------------
int vBase 			 = 75;
int const vMax   = 80;
int const vMin	 = 10;
int const vAlertMax = 70;
//int const vAlert = 90;
int const maxI	 = 10;
float const k 	 = 38;
int iAlert			 = 0;
bool leftAlert   = false;
bool rightAlert  = false;
//--------------------
bool recOn       = false;
power p[300];
//--------------------
task speedUp()
{
	int vFinish        = vBase;
	int const vStart   = 30;
	int const tSpeedUp = 600;
	int tSleep = tSpeedUp / ( vFinish - vStart );

	for ( int i = vStart ; i <= vFinish ; i++ )
	{
		vBase = i ;
		sleep(tSleep);
	}
}

//--------------------
task main()
{

	LLinit(sLightLeft); 	// Set up Line Leader sensor type
	LLinit(sLightRight); 	// Set up Line Leader sensor type
	_lineLeader_cmd(sLightLeft, 'E'); // European frequency compensation
	_lineLeader_cmd(sLightRight, 'E'); // European frequency compensation

	calibrate();
	waitTouchRelease();
	startTask(speedUp);

	tByteArray rawLightLeft;
	tByteArray rawLightRight;

	int e       		= 0;
	int fps 				= 0;
	int eOld 				= e;
	int rwLeft  		= getRWLeft(rawLightLeft);
	int rwRight 		= getRWRight(rawLightRight);
	int es 					= rwLeft - rwRight;
	float i 				= 0;
	int 	v 				= 0 ;
	int   u					= 0 ;
	int vLeft 			= 0;
	int vRight 			= 0;

	long iSpeed     = 0;
	int iRec        = 0;
	leftAlert  			= false;
	rightAlert 			= false;

	clearTimer(T1);

	while(time1[T1] < 4000)
	{
		//------------
	/*	if (rightAlert)
			rwRight = getRWRight(rawLightRight);
		else if (leftAlert)
			rwLeft = getRWLeft(rawLightLeft);
		else if(fps %2 == 0)
			rwLeft = getRWLeft(rawLightLeft);
		else
			rwRight = getRWRight(rawLightRight);
		*/
		rwLeft = getRWLeft(rawLightLeft);
		rwRight = getRWRight(rawLightRight);
		//------------

		if ((rightAlert == false) && (rawLightLeft[7] < 20) && ((rawLightLeft[1] > 40) || (rawLightLeft[0] > 40))) leftAlert = true;
		if (leftAlert && (iAlert > 0)) leftAlert = ((rawLightLeft[4] > 20) &&
			(rawLightLeft[3] > 20) &&
		(rawLightLeft[2] > 20) &&
		(rawLightLeft[1] > 20) &&
		(rawLightLeft[0] > 20) &&
		(rawLightRight[0] > 20) &&
		(rawLightRight[1] > 20) &&
		(rawLightRight[2] > 20) &&
		(rawLightRight[3] > 20) &&
		(rawLightRight[4] > 20) &&
		(rawLightRight[5] > 20) &&
		(rawLightRight[6] > 20) &&
		(rawLightRight[7] > 20));
		if (leftAlert) rightAlert = false;

		if ((leftAlert == false) && (rawLightRight[0] < 20) && ((rawLightRight[6] > 40) || (rawLightRight[7] > 40))) rightAlert = true;
		if (rightAlert && (iAlert > 0)) rightAlert = ((rawLightRight[3] > 20) &&
			(rawLightRight[4] > 20) &&
		(rawLightRight[5] > 20) &&
		(rawLightRight[6] > 20) &&
		(rawLightRight[7] > 20) &&
		(rawLightLeft[0] > 20) &&
		(rawLightLeft[1] > 20) &&
		(rawLightLeft[2] > 20) &&
		(rawLightLeft[3] > 20) &&
		(rawLightLeft[4] > 20) &&
		(rawLightLeft[5] > 20) &&
		(rawLightLeft[6] > 20) &&
		(rawLightLeft[7] > 20));
		if (rightAlert) leftAlert = false;
		//--------------
		e = rwLeft - rwRight - es;

		if (leftAlert)
		{
			if (recOn == false) recOn = true;
			iAlert ++;
			vLeft  -= 5;
			vRight += 5;
			if (vRight > vAlertMax) vRight = vAlertMax;
			//vLeft  = vMin;
			//vRight = vAlert ;
		}
		else if (rightAlert)
		{
			if (recOn == false) recOn = true;
			iAlert ++;
			vLeft  += 5;
			vRight -= 5;
			if (vLeft > vAlertMax) vLeft = vAlertMax;

			//vLeft  = vAlert;
			//vRight = vMin;
		}
		else
		{
			if ( iAlert != 0 )
			{
				i = 0;
				iSpeed = 0;
			}

			i = i + e / 2500;
			if ( fabs(i) > maxI ) i = sgn(i) * maxI ;
			u = (e * 1  + (e - eOld ) * 7) / k  + i;
			v = (vBase - abs (u) * 0.65 ) ;

			vLeft = v + u;
			vRight = v - u;

			iAlert = 0;
		}

		eOld = e ;

		if (vLeft  < vMin)  vLeft  = vMin;
		if (vRight < vMin)  vRight = vMin;
		if (vLeft  > vMax)  vLeft  = vMax;
		if (vRight > vMax)  vRight = vMax;

#ifdef RELEASE
	/*
	vLeft = (vLeft + vLeftOld)   /2;
	vRight= (vRight + vRightOld) /2;
	vLeftOld = vLeft;
	vRightOld = vRight;
	*/
		if (recOn)
		{
			p[iRec].left = vLeft;
			p[iRec].right = vRight;
			iRec++;
		}

		motor[mLeft]  = vLeft;
		motor[mRight] = vRight;
#endif
#ifdef DEBUG
		displayTextLine(0,"rwL %d",rwLeft);
		displayTextLine(1,"rwR %d", rwRight);
		displayTextLine(2,"lAlert %d", leftAlert);
		displayTextLine(3,"rAlert %d",rightAlert);
		displayTextLine(4,"e %d",e);
		displayTextLine(5,"u %d",u);
		displayTextLine(6,"vLeft %d",vLeft);
		displayTextLine(7, "vRight %d",vRight);
#endif
		fps++;
		//sleep (1);
	}
	LLsleep(sLightLeft);  // Sleep to conserve power when not in use
	LLsleep(sLightRight); // Sleep to conserve power when not in use

	motor[mLeft]  = 0;
	motor[mRight] = 0;

	eraseDisplay();
	displayBigTextLine(4, "writting...");
	safeToFile(p, iRec + 1);
	displayBigTextLine(4, "  Done");
	sleep(1000);
	displayBigTextLine(4, "fps: %d", fps);
	sleep(15000);
	}

//---------------------------------

void calibrate ()
{
	displayBigTextLine(4, "  WHITE");

	while(true)
	{
		if (nNxtButtonPressed == 3)
		{
			while (nNxtButtonPressed == 3)
			{
				sleep (10);
			}
			break;
		}
		sleep (10);
	}
	LLcalWhite(sLightLeft);
	LLcalWhite(sLightRight);

	playSound(soundBlip);

	displayBigTextLine(4, "   Done");

	sleep(1000);

	displayBigTextLine(4, "  BLACK");

	while(true)
	{
		if (nNxtButtonPressed == 3)
		{
			while (nNxtButtonPressed == 3)
			{
				sleep (10);
			}
			break;
		}
		sleep (10);
	}
	LLcalBlack(sLightLeft);
	LLcalBlack(sLightRight);

	playSound(soundBlip);

	displayBigTextLine(4, "  Done");

	sleep(1000);
}

//-------------------------------

void waitTouchRelease()
{
	displayBigTextLine(4, " START");

	while(true)
	{
		if (nNxtButtonPressed == 3)
		{
			while (nNxtButtonPressed == 3)
			{
				sleep (10);
			}
			break;
		}
		sleep (10);
	}
	eraseDisplay();
}
//---------------
int getRWLeft(tByteArray rawLight)
{

	LLreadSensorRaw(sLightLeft, rawLight);
	int r =
	(
	rawLight[0]  +
	rawLight[1]  +
	rawLight[2]  +
	rawLight[3]  +
	rawLight[4]  +
	rawLight[5]  +
	rawLight[6]  +
	rawLight[7]
	) ;
	if (( rawLight[7] < 10 ) && ( rawLight[0] > 10 )) r = r * -1;
	return r;
}
//--------------------
int getRWRight(tByteArray rawLight)
{

	LLreadSensorRaw(sLightRight, rawLight);
	int r =
	(
	rawLight[0] +
	rawLight[1] +
	rawLight[2] +
	rawLight[3] +
	rawLight[4] +
	rawLight[5] +
	rawLight[6] +
	rawLight[7]
	) ;
	if (( rawLight[0] < 10 ) && ( rawLight[7] > 10 )) r = r * -1;
	return r;
}

void safeToFile(power *p, int size){

	TFileHandle hFile;
	TFileIOResult ioResult;
	string fileName = "r0.bin";
	short sizeFile = size * sizeof(power);

	Delete(fileName , ioResult);
	OpenWrite(hFile, ioResult, fileName, sizeFile);

	for (int i = 0 ; i < size; i++)
	{
		WriteByte(hFile, ioResult, p[i].left);
		WriteByte(hFile, ioResult, p[i].right);
	}

	Close(hFile, ioResult);
}

MODE getMode(){

	MODE mode = MODE_REC;

	displayBigTextLine(4, "MODE");
	sleep(1000);

	while(true)
	{
		if (mode == MODE_PLAY)
			displayBigTextLine(4, " PLAY");
		else
			displayBigTextLine(4, "RECORD");

		if (nNxtButtonPressed == 3)
		{
			while (nNxtButtonPressed == 3)
			{
				sleep (10);
			}
			return mode;
		}

		if (nNxtButtonPressed == 1)
		{
			while (nNxtButtonPressed == 1)
			{
				sleep (10);
			}
			mode = revertMode(mode);
		}

		if (nNxtButtonPressed == 2)
		{
			while (nNxtButtonPressed == 2)
			{
				sleep (10);
			}
			mode = revertMode(mode);
	}
		sleep (10);
	}
}

MODE revertMode(MODE mode) {
	if (mode == MODE_PLAY) return MODE_REC;
	return MODE_PLAY;
}
