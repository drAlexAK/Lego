#pragma config(Sensor, S1,     sDistB1,        sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S2,     sDistB2,        sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S3,     sDistA2,        sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S4,     sDistA1,        sensorI2CCustomFastSkipStates9V)
#pragma config(Motor,  motorA,          mLightA,       tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          mLightB,       tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// includes
//
#include "mindsensors-irdist.h"

// defines
//
#define DEBUG

#define ZONE_A -1
#define ZONE_B 1
//
#define DIST_SHORT     150    // calculates minimum distance for short distance sensor
#define DIST_MIN_IGNORE 50   // minimum of distance
#define INTERVAL_SMALL 40     // sleep interval for release car
#define INTERVAL_LONG  40     // sleep interval for new car
#define IR_COUNT			 3      // repeats quantity
//
// light
const int vMaxLight = 40;
const int vMinLight = 5;
const int degreeA   = 145; //170;
const int degreeB   = 145;
// headers
//
task counterA1();
task counterA2();
task counterB1();
task counterB2();

void Switch(int direction);
int selectZone(int startZone);

#ifdef DEBUG
task displayInfo();
#endif

// variables
//
int  qA        = 0;     // queue in the zone A
bool stopLineA = false; // car stops near stop line zone A
int  qB        = 0;     // queue in the zone B
bool stopLineB = false; // car stops near stop line zone B

task main()
{

	int activeZone = selectZone(ZONE_A);
	eraseDisplay();
	displayBigTextLine(4,"initializing",);

	startTask(counterA1);
	sleep(500);
	startTask(counterA2);
	sleep(500);
	startTask(counterB1);
	sleep(500);
	startTask(counterB2);
	sleep(500);
	eraseDisplay();

#ifdef DEBUG
	startTask(displayInfo);
#endif
	while(true)
	{
		sleep(100);
		// nNxtButtonPressed 0 = Gray Rectangle button. 1 = Right Arrow button. 2 = Left Arrow button. 3 = Orange Square button.
		if (nNxtButtonPressed == 3) // reset counters
		{
			qA        = 0;     // queue in the zone A
			stopLineA = false; // car stops near stop line zone A7
			qB        = 0;     // queue in the zone B
			stopLineB = false; // car stops near stop line zone B
		}
		int lightDirection = qA - qB ;

		if ((lightDirection > 0) && (activeZone != ZONE_A))
		{
			activeZone = ZONE_A;
			Switch(ZONE_A);
		}
		else if ((lightDirection < 0) && (activeZone != ZONE_B))
		{
			activeZone = ZONE_B;
			Switch(ZONE_B);
		}
	}
}

void Switch(int direction)
{
	nMotorEncoder[mLightA] = 0;
	nMotorEncoder[mLightB] = 0;

	while( (abs(nMotorEncoder[mLightA]) < degreeA ) || ( abs(nMotorEncoder[mLightB]) < degreeB ) ){

		if(abs(nMotorEncoder[mLightA]) >= degreeA)
			motor[mLightA] =0;
		else
			motor[mLightA] = direction * (vMaxLight - ((vMaxLight - vMinLight) * (nMotorEncoder[mLightA] / degreeA))) ;

		if(abs(nMotorEncoder[mLightB]) >= degreeB)
			motor[mLightB] =0;
		else
			motor[mLightB] = (-1 * direction) * (vMaxLight - ((vMaxLight - vMinLight) * (nMotorEncoder[mLightB] / degreeB))) ;
	}
	motor[mLightA] =0;
	motor[mLightB] =0;
}

task counterA1()
{
	int d = 0 ;
	int i =0;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistA1, address);
	while(true)
	{
		while(i <=IR_COUNT){
			while ((d  > DIST_SHORT)  || (d < DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistA1, address);
				i =0;
			}
			i++;
		}
		i =0;
		while(i <= IR_COUNT){
			while ((d  <= DIST_SHORT)  && (d >= DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistA1, address);
				i=0;
			}
			i++;
		}
		qA++;
		i=0;
	}
}

task counterA2()
{
	int d = 0 ;
	int i =0;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistA2, address);
	while(true)
	{
		while(i <=IR_COUNT){
			while ((d  > DIST_SHORT)  || (d < DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistA2, address);
				i =0;
			}
			i++;
		}
		i =0;
		while(i <= IR_COUNT){
			while ((d  <= DIST_SHORT)  && (d >= DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistA2, address);
				i=0;
			}
			i++;
		}
		qA--;
		i=0;
	}
}

task counterB1()
{
	int d = 0 ;
	int i = 0 ;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistB1, address);
	while(true)
	{
		while(i <=IR_COUNT){
			while ((d  > DIST_SHORT) || (d < DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistB1, address);
				i =0;
			}
			i++;
		}
		i =0;
		while(i <= IR_COUNT){
			while ((d  <= DIST_SHORT)  && (d >= DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistB1, address);
				i=0;
			}
			i++;
		}
		qB++;
		i=0;
	}
}

task counterB2()
{
	int i =0;
	int d = 0 ;
	ubyte address = 0x02;
	string type = MSDISTreadModuleType(sDistB2, address);
	while(true)
	{
		while(i <= IR_COUNT){
			while ((d  > DIST_SHORT) || (d < DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistB2, address);
				i =0;
			}
			i++;
		}
		i =0;
		while(i <= IR_COUNT){
			while ((d  <= DIST_SHORT) && (d >= DIST_MIN_IGNORE)){
				sleep(INTERVAL_LONG);
				d = MSDISTreadDist(sDistB2, address);
				i=0;
			}
			i++;
		}
		qB--;
		i=0;
	}
}
task displayInfo()
{
	while(true)
	{
		displayTextLine(0,"A %d        ",qA);
		displayTextLine(1,"stopA %d   ",stopLineA);
		displayTextLine(2,"B1 %d        ",qB);
		displayTextLine(3,"stopB %d   ",stopLineB);
		sleep(100);
	}
}
int selectZone(int startZone){
	int z = startZone;
	while(nNxtButtonPressed != 3)
	{
		if((nNxtButtonPressed == 1) || (nNxtButtonPressed == 2))
		{
			while((nNxtButtonPressed == 1) || (nNxtButtonPressed == 2)) sleep(10);

			z *= -1;
			if(z == ZONE_B) displayBigTextLine(4,"    B",);
			else displayBigTextLine(4,"    A",);
		}
	}
	return z;
}
