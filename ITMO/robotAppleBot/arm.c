#pragma config(Sensor, S1,     ,               sensorI2CCustomFastSkipStates9V)
#pragma config(Motor,  motorA,          mPl,           tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          mArm,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          mLandle,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "alex-common.h"
#include "shared.h"
#include "nxtPipe.h"
#include "mindsensors-irdist.h"
//----------------------------
//
//#define DEBUG
//
#define ARM_270MM_ENCODER 				9340
#define ARM_MAX_POSITION_270MM    270
#define M_ARM_SPEED_MIN           20
#define M_ARM_SPEED_MAX           100
#define LANDLE_11000_ENCODER      2000 // 11000
#define M_LANDLE_SPEED_MIN        10
#define M_LANDLE_SPEED_MAX        100
//----------------------------
#define MAX_CENTER_MM 125
#define MAX_CENTER_ENC 	1810
#define M_PL_SPEED_MIN 10
#define M_PL_SPEED_MAX 80
//----------------------------
// semaphore variables
TSemaphore  semParkingArm;
TSemaphore  semParkingPl;
TSemaphore  semParkingLandle;
//----------------------------
void upArmMM(int posit);
//void upArmMMStrongVert(int posit);
void resetMotorsEncoder();
void upLandle(bool up);
void Parking();
task ParkingArm();
task ParkingPl();
task ParkingLandle();
task holdPlPositionByArm();
void executeCMD(COMMAND cmd,int value);
void InitArmDiffMM();
void movePl(int posit);
int getPlPositionByArmEnc(int enc);
int getPlPositionByArmMM(int posit);
int getPlCurrentPositionMM();
//----------------------------
bool CurrentPositionLandle 			  = true;
//----------------------------

byte armDiffMM[28] ;

task main()
{
	InitArmDiffMM();
	resetMotorsEncoder();

	startTask(holdPlPositionByArm);
	upArmMM(100);
	sleep(1000);
	upArmMM(200);
	sleep(1000);
	upArmMM(50);
	sleep(1000);
	upArmMM(270);
	sleep(1000);
	upArmMM(0);
	sleep(3000);
	stopTask(holdPlPositionByArm);
	Parking();
	stopAllTasks();
	return;


	startTask(holdPlPositionByArm);
	upArmMM(270);
	upLandle(true);
	sleep(5000);
	upArmMM(100);
	upLandle(false);
	sleep(5000);
	upArmMM(200);
	upLandle(true);
	sleep(5000);
	upArmMM(0);
	sleep(5000);
	stopTask(holdPlPositionByArm);
	Parking();
	stopAllTasks();
	return;


	/*
	upArmMMStrongVert(270);
	sleep(3000);
	upArmMMStrongVert(100);
	sleep(3000);
	upArmMMStrongVert(0);
	sleep(3000);
	upArmMMStrongVert(270);
	sleep(3000);

	Parking();
	stopAllTasks();
	return;

	ubyte id =0;
	COMMAND cmd ;
	int value =0;

	InitialyzePipe();

	while(true){
	if((inDelivery.Size > 0) && (inDelivery.Status == MSG_STATUS_DELIVERED)){
	id = inDelivery.Msg[MSG_HEAD_INDEX_ID];
	if(inDelivery.Size == COMMAND_MSG_SIZE + MSG_HEADER_SIZE){
	getCommand(inDelivery.Msg, cmd, value);
	executeCMD(cmd, value);
	if (id == inDelivery.Msg[MSG_HEAD_INDEX_ID]) {
	inDelivery.Status = (MSG_STATUS) MSG_STATUS_COMPLETED;
	}
	SendCompleteReplayMsg(id);
	}
	}
	sleep(200);
	}

	//Parking();

	stopAllTasks();
	*/
}

void resetMotorsEncoder() {
	nMotorEncoder[mArm]    = 0;
	nMotorEncoder[mLandle] = 0;
	nMotorEncoder[mPl]     = 0;
}

void executeCMD(COMMAND cmd, int value){
	switch (cmd)
	{
	case CMD_UP_ARM:
		upArmMM(value);
		break;
	case CMD_UP_ARM_STR_VERT:
		//upArmMMStrongVert(value);
		break;
	case CMD_MOVE_PL:
		movePl(value);
	case CMD_UP_LANDLE:
		upLandle((bool) value);
		break;
	case CMD_PARK_ALL:
	default:
		Parking();
		break;
	}
}

void Parking(){
	semaphoreInitialize(semParkingArm);
	semaphoreInitialize(semParkingPl);
	semaphoreInitialize(semParkingLandle);

	startTask(ParkingArm);
	sleep(100);
	startTask(ParkingPl);
	sleep(100);
	startTask(ParkingLandle);

	sleep(100);
	semaphoreLock( semParkingArm );
	semaphoreLock( semParkingPl );
	semaphoreLock( semParkingLandle );

	if (bDoesTaskOwnSemaphore(semParkingArm)) semaphoreUnlock(semParkingArm);
	if (bDoesTaskOwnSemaphore(semParkingPl)) semaphoreUnlock(semParkingPl);
	if (bDoesTaskOwnSemaphore(semParkingLandle)) semaphoreUnlock(semParkingLandle);
}

task ParkingArm(){
	semaphoreLock( semParkingArm );
	upArmMM(0);
	if (bDoesTaskOwnSemaphore(semParkingArm)) semaphoreUnlock(semParkingArm);
}
task ParkingLandle(){
	semaphoreLock( semParkingLandle );
	upLandle(true);
	if (bDoesTaskOwnSemaphore(semParkingLandle)) semaphoreUnlock(semParkingLandle);
}
task ParkingPl(){
	semaphoreLock( semParkingPl );
	movePl(0);
	if (bDoesTaskOwnSemaphore(semParkingPl)) semaphoreUnlock(semParkingPl);
}

void upLandle(bool up)
{
	if (CurrentPositionLandle == up) return;

	int	targetEnc = (up ? 0 : -1 * LANDLE_11000_ENCODER) ;
	int startEnc = nMotorEncoder[mLandle];
	int speed = 0 ;
	if( up ){
		while(nMotorEncoder[mLandle] < targetEnc){
			speed = getLimitSpeed(M_LANDLE_SPEED_MIN, M_LANDLE_SPEED_MAX, startEnc, nMotorEncoder[mLandle], targetEnc);
			motor[mLandle] = speed;
		}
		} else {
		while(nMotorEncoder[mLandle] > targetEnc){
			speed = getLimitSpeed(M_LANDLE_SPEED_MIN, M_LANDLE_SPEED_MAX, startEnc, nMotorEncoder[mLandle], targetEnc);
			motor[mLandle]= speed;
		}
	}
	motor[mLandle] = 0;
	CurrentPositionLandle = up;
}

void upArmMM(int posit){
	if (posit < 0) posit = 0;
	if (posit > ARM_MAX_POSITION_270MM) posit = ARM_MAX_POSITION_270MM;

	int	targetEnc = (ARM_270MM_ENCODER * posit) / ARM_MAX_POSITION_270MM;
	int startEnc  = nMotorEncoder[mArm];
	int speed = 0 ;
	if ((targetEnc - startEnc) > 0){
		while(nMotorEncoder[mArm] < targetEnc){
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, startEnc, nMotorEncoder[mArm], targetEnc);
			motor[mArm] = speed;
		}
		} else {
		while(nMotorEncoder[mArm] > targetEnc){
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, startEnc, nMotorEncoder[mArm], targetEnc);
			motor[mArm] = speed;
		}
	}
	motor[mArm] = 0;
}

int getPlPositionByArmEnc(int enc){
	int armPositMM = ARM_MAX_POSITION_270MM  * enc / ARM_270MM_ENCODER;
	return getPlPositionByArmMM(armPositMM);
	//return (MAX_CENTER_ENC * platformPositionMM) / MAX_CENTER_MM ;
}

int getPlCurrentPositionMM(){
	return nMotorEncoder[mArm] * MAX_CENTER_MM / MAX_CENTER_ENC;
}

int getPlPositionByArmMM(int posit){
	posit = abs(posit);
	if (posit > ARM_MAX_POSITION_270MM) posit = ARM_MAX_POSITION_270MM;
	if (posit % 10 == 0) return armDiffMM[posit/10];
	int a = posit / 10;
	int b = a + 1;
	if (( b > 27 ) || ( a> 27 )) return armDiffMM[27];
	return armDiffMM[a] + ((armDiffMM[b] - armDiffMM[a]) * (posit - a * 10) / (b * 10 - a * 10));
}

void InitArmDiffMM()
{
	armDiffMM[0] = 0; //5;
	armDiffMM[1] = 3; //8;
	armDiffMM[2] = 5; //13;
	armDiffMM[3] = 7;
	armDiffMM[4] = 9;
	armDiffMM[5] = 10;
	armDiffMM[6] = 10;
	armDiffMM[7] = 11;
	armDiffMM[8] = 11;
	armDiffMM[9] = 10;
	armDiffMM[10] = 7;
	armDiffMM[11] = 6;
	armDiffMM[12] = 3;
	armDiffMM[13] = 2;
	armDiffMM[14] = 3;
	armDiffMM[15] = 0;
	armDiffMM[16] = -2;
	armDiffMM[17] = -3;
	armDiffMM[18] = -6;
	armDiffMM[19] = -9;
	armDiffMM[20] = -10;
	armDiffMM[21] = -15;
	armDiffMM[22] = -18;
	armDiffMM[23] = -24;
	armDiffMM[24] = -31;
	armDiffMM[25] = -40;
	armDiffMM[26] = -47;
	armDiffMM[27] = -58;
}

void movePl(int posit){
	if (abs(posit) > MAX_CENTER_MM) posit = sgn(posit) * MAX_CENTER_MM;
	int	targetEnc = (MAX_CENTER_ENC * posit) / MAX_CENTER_MM;
	int startEnc = nMotorEncoder[mPl];
	int speed = 0;
	if((targetEnc - startEnc) > 0){
		while(nMotorEncoder[mPl] < targetEnc){
			speed = getLimitSpeed(M_PL_SPEED_MIN, M_PL_SPEED_MAX, startEnc, nMotorEncoder[mPl], targetEnc);
			motor[mPl] = speed;
		}
		} else {
		while(nMotorEncoder[mPl] > targetEnc){
			speed = getLimitSpeed(M_PL_SPEED_MIN, M_PL_SPEED_MAX, startEnc, nMotorEncoder[mPl], targetEnc);
			motor[mPl]= speed;
		}
	}
	motor[mPl]=0;
}


task holdPlPositionByArm()
{
	const int accuracy = 3;
	int HoldPositionPlEnc = nMotorEncoder[mPl];
	int targetEnc = 0;
	int startEnc = 0;
	int speed = 0;

	while(true){
		targetEnc = HoldPositionPlEnc - (MAX_CENTER_ENC * getPlPositionByArmEnc(nMotorEncoder[mArm])) / MAX_CENTER_MM;
		if (abs(targetEnc) > MAX_CENTER_ENC) targetEnc = sgn(targetEnc) * MAX_CENTER_ENC;
		startEnc = nMotorEncoder[mPl];
		if((targetEnc - startEnc) > 0){
			while(((nMotorEncoder[mPl] - accuracy) < targetEnc) && ((nMotorEncoder[mPl] + accuracy) < targetEnc)){
				speed = getLimitSpeed(M_PL_SPEED_MIN, M_PL_SPEED_MAX, startEnc, nMotorEncoder[mPl], targetEnc);
				motor[mPl] = speed;

			}
			} else {
			while(((nMotorEncoder[mPl] - accuracy) > targetEnc) && ((nMotorEncoder[mPl] + accuracy) > targetEnc)) {
				speed = getLimitSpeed(M_PL_SPEED_MIN, M_PL_SPEED_MAX, startEnc, nMotorEncoder[mPl], targetEnc);
				motor[mPl]= speed;
			}
		}
		motor[mPl]=0;
		sleep(10);
	}
}
/*
void upArmMMStrongVert(int posit){
if (posit<0) posit = 0;
if (posit>ARM_MAX_POSITION_270MM) posit = ARM_MAX_POSITION_270MM;
nMotorEncoder[mArm] =0;
int	enc = (ARM_270MM_ENCODER * posit) / ARM_MAX_POSITION_270MM - nMotorEncoder[mArm];

int currentEnc = nMotorEncoder[mArm];
int speed = 0 ;
int pp = 0;
if(enc > 0){
while(currentEnc < enc){
pp = getPlPositionByArmEnc(abs(currentEnc)) - getPlCurrentPositionMM();
movePl(pp+10);
speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
motor[mArm] = speed;
currentEnc = nMotorEncoder[mArm];
}
} else {
while(currentEnc > enc){
pp = getPlPositionByArmEnc(abs(currentEnc)) - getPlCurrentPositionMM();
movePl(pp-10);
speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
motor[mArm]= -1 * speed;
currentEnc = nMotorEncoder[mArm];
}
}
motor[mArm]=0;
}
*/
/*
void getArrayDistFromLadleDependsOnArm(){

TFileHandle   hFileHandle;              // will keep track of our file
TFileIOResult nIOResult;                // will store our IO results
string        sFileName = "Landle.txt";   // the name of our file
short         nFileSize = 1000;          // will store our file size
string result = "";

byte CR = 0x13;   // define CR (carriage return)
byte LF = 0x10;   // define LF (line feed)

OpenWrite( hFileHandle, nIOResult, sFileName, nFileSize);    // open the file for writing (creates the file if it does not exist)
int d = MSDISTreadDist(S1);
int a[7];
for(int i = 0; i <= 270; i += 10){
upArmMM(i);
sleep(3000);
for(int j =0; j <7;j++){
a[j] = MSDISTreadDist(S1);
sleep(500);
}
sprintf(result, "%d %d\n\r", i , GetMedian(a,7));
WriteText(hFileHandle, nIOResult, result);         // write 'sMessageToWrite' to the file
//WriteByte(hFileHandle, nIOResult, CR);                      // write 'CR' to the file (carriage return)
//WriteByte(hFileHandle, nIOResult, LF);                      // write 'LF' to the file (line feed)
}
Close(hFileHandle, nIOResult);                              // close our file (DON'T FORGET THIS STEP!)
}
*/
