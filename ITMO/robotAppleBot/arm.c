#pragma config(Sensor, S1,     ,               sensorI2CCustomFastSkipStates9V)
#pragma config(Motor,  motorA,          mPl,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mArm,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          mLandle,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "alex-common.h"
#include "shared.h"
#include "nxtPipe.h"
#include "mindsensors-irdist.h"
//----------------------------
//
//#define DEBUG
//
#define ARM_270MM_ENCODER 				9340
#define ARM_MAX_POSITION_270MM    270
#define M_ARM_SPEED_MIN           20
#define M_ARM_SPEED_MAX           100
#define LANDLE_11000_ENCODER      2500 // 11000
#define M_LANDLE_SPEED_MIN        10
#define M_LANDLE_SPEED_MAX        100
//----------------------------
#define MAX_CENTER_MM 125
#define MAX_CENTER_ENC 1450
#define M_PL_SPEED_MIN 15
#define M_PL_SPEED_MAX 60
//----------------------------
void upArmMM(int posit);
void upLandle(bool up);
void Parking();
task ParkingArm();
task ParkingPl();
task ParkingLandle();
void executeCMD(COMMAND cmd,int value);
void InitArmDiffMM();
void movePL(int posit);
//----------------------------
int  CurrentPositionArmEnc 			= 0;
bool CurrentPositionLandle 			= true;
int  CurrentPositionPlEnc = 0;
//----------------------------

ubyte armDiffMM[28] ;

task main()
{
	InitArmDiffMM();

	ubyte id =0;
	COMMAND cmd ;
	int value =0;

	InitialyzePipe();

	while(true){
		if((inDelivery.Size > 0) && (inDelivery.Status == MSG_STATUS_DELIVERED)){
			id = inDelivery.Msg[MSG_HEAD_INDEX_ID];
			if(inDelivery.Size == COMMAND_MSG_SIZE + MSG_HEADER_SIZE){
				getCommand(inDelivery.Msg, cmd, value);
				executeCMD(cmd, value);
				if (id == inDelivery.Msg[MSG_HEAD_INDEX_ID]) {
					inDelivery.Status = (MSG_STATUS) MSG_STATUS_COMPLETED;
				}
				SendCompleteReplayMsg(id);
			}
		}
		sleep(200);
	}

	//Parking();

	stopAllTasks();
}

void executeCMD(COMMAND cmd,int value){
	switch (cmd)
	{
	case CMD_UP_ARM:
		upArmMM(value);
		break;
	case CMD_MOVE_PL:
	 movePL(value);
	case CMD_UP_LANDLE:
		upLandle((bool) value);
		break;
	case CMD_PARK_ALL:
	default:
		Parking();
		break;
	}
}

void Parking(){
	startTask(ParkingArm);
	startTask(ParkingPl);
	startTask(ParkingLandle);
	while((CurrentPositionArmEnc != 0) ||
		(CurrentPositionPlEnc != 0) ||
	(CurrentPositionLandle != true)){
		sleep(100);
	}
}

task ParkingArm(){
	upArmMM(0);
}
task ParkingLandle(){
	upLandle(true);
}
task ParkingPl(){
	movePL(0);
}

void upLandle(bool up)
{
	if (CurrentPositionLandle == up) return;
	nMotorEncoder[mLandle] =0;
	int	enc = up ? (LANDLE_11000_ENCODER) : (-1 * LANDLE_11000_ENCODER) ;
	int currentEnc = nMotorEncoder[mLandle];
	int speed = 0 ;
	if(up){
		while(currentEnc < enc){
			speed = getLimitSpeed(M_LANDLE_SPEED_MIN, M_LANDLE_SPEED_MAX, currentEnc, enc);
			motor[mLandle] = speed;
			currentEnc = nMotorEncoder[mLandle];
		}
		} else {
		while(currentEnc > enc){
			speed = getLimitSpeed(M_LANDLE_SPEED_MIN, M_LANDLE_SPEED_MAX, currentEnc, enc);
			motor[mLandle]= -1 * speed;
			currentEnc = nMotorEncoder[mLandle];
		}
	}
	motor[mLandle]=0;
	CurrentPositionLandle = up;
}

void upArmMM(int posit){
	if (posit<0) posit = 0;
	if (posit>ARM_MAX_POSITION_270MM) posit = ARM_MAX_POSITION_270MM;
	nMotorEncoder[mArm] =0;
	int	enc = (ARM_270MM_ENCODER * posit) / ARM_MAX_POSITION_270MM - CurrentPositionArmEnc;

	int currentEnc = nMotorEncoder[mArm];
	int speed = 0 ;
	if(enc > 0){
		while(currentEnc < enc){
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
			motor[mArm] = speed;
			currentEnc = nMotorEncoder[mArm];
		}
		} else {
		while(currentEnc > enc){
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
			motor[mArm]= -1 * speed;
			currentEnc = nMotorEncoder[mArm];
		}
	}
	motor[mArm]=0;
	CurrentPositionArmEnc +=  nMotorEncoder[mArm];
}

int getPLPositionByArmMM(int posit){
	if (posit<0) posit = 0;
	if (posit>ARM_MAX_POSITION_270MM) posit = ARM_MAX_POSITION_270MM;
	if(posit %10 == 0)return armDiffMM[posit/10];
	int a= 0;
	int b =0;
	a = posit / 10;
	b = a+1;
	return armDiffMM[a] + ((armDiffMM[b] - armDiffMM[a]) * (posit - a * 10) / (b * 10 - a * 10));
}

void InitArmDiffMM()
{
	armDiffMM[0] = 51;
	armDiffMM[1] = 48;
	armDiffMM[2] = 43;
	armDiffMM[3] = 56;
	armDiffMM[4] = 51;
	armDiffMM[5] = 45;
	armDiffMM[6] = 40;
	armDiffMM[7] = 33;
	armDiffMM[8] = 28;
	armDiffMM[9] = 23;
	armDiffMM[10] = 18;
	armDiffMM[11] = 14;
	armDiffMM[12] = 12;
	armDiffMM[13] = 9;
	armDiffMM[14] = 5;
	armDiffMM[15] = 3;
	armDiffMM[16] = 1;
	armDiffMM[17] = 0;
	armDiffMM[18] = 0;
	armDiffMM[19] = 1;
	armDiffMM[20] = 3;
	armDiffMM[21] = 5;
	armDiffMM[22] = 8;
	armDiffMM[23] = 12;
	armDiffMM[24] = 18;
	armDiffMM[25] = 25;
	armDiffMM[26] = 33;
	armDiffMM[27] = 44;
}

void movePL(int posit){
	//if (posit < 0) posit = 0;
	if (abs(posit) > MAX_CENTER_MM) posit = sgn(posit) * MAX_CENTER_MM;
	nMotorEncoder[mPl] =0;
	int	enc = (MAX_CENTER_ENC * posit) / MAX_CENTER_MM - CurrentPositionPlEnc;

	int currentEnc = nMotorEncoder[mPl];
	int speed = 0;
	if(enc > 0){
		while(currentEnc < enc){
			speed = getLimitSpeed(M_PL_SPEED_MIN, M_PL_SPEED_MAX, currentEnc, enc);
			motor[mPl] = speed;
			currentEnc = nMotorEncoder[mPl];
		}
		} else {
		while(currentEnc > enc){
			speed = getLimitSpeed(M_PL_SPEED_MIN, M_PL_SPEED_MAX, currentEnc, enc);
			motor[mPl]= -1 * speed;
			currentEnc = nMotorEncoder[mPl];
		}
	}
	motor[mPl]=0;
	CurrentPositionPlEnc +=  nMotorEncoder[mPl];
}

void upArmMMStrongVert(int posit){
	if (posit<0) posit = 0;
	if (posit>ARM_MAX_POSITION_270MM) posit = ARM_MAX_POSITION_270MM;
	nMotorEncoder[mArm] =0;
	int	enc = (ARM_270MM_ENCODER * posit) / ARM_MAX_POSITION_270MM - CurrentPositionArmEnc;

	int currentEnc = nMotorEncoder[mArm];
	int speed = 0 ;
	if(enc > 0){
		while(currentEnc < enc){
			movePL(CurrentPositionPlEnc + getPLPositionByArmMM(currentEnc));
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
			motor[mArm] = speed;
			currentEnc = nMotorEncoder[mArm];
		}
		} else {
		while(currentEnc > enc){
			movePL(CurrentPositionPlEnc + getPLPositionByArmMM(currentEnc));
			speed = getLimitSpeed(M_ARM_SPEED_MIN, M_ARM_SPEED_MAX, currentEnc, enc);
			motor[mArm]= -1 * speed;
			currentEnc = nMotorEncoder[mArm];
		}
	}
	motor[mArm]=0;
	CurrentPositionArmEnc +=  nMotorEncoder[mArm];
}

/*
void getArrayDistFromLadleDependsOnArm(){

	TFileHandle   hFileHandle;              // will keep track of our file
	TFileIOResult nIOResult;                // will store our IO results
	string        sFileName = "Landle.txt";   // the name of our file
	short         nFileSize = 1000;          // will store our file size
	string result = "";

	byte CR = 0x13;   // define CR (carriage return)
	byte LF = 0x10;   // define LF (line feed)

	OpenWrite( hFileHandle, nIOResult, sFileName, nFileSize);    // open the file for writing (creates the file if it does not exist)
	int d = MSDISTreadDist(S1);
	int a[7];
	for(int i = 0; i <= 270; i += 10){
		upArmMM(i);
		sleep(3000);
		for(int j =0; j <7;j++){
			a[j] = MSDISTreadDist(S1);
			sleep(500);
		}
		sprintf(result, "%d %d\n\r", i , GetMedian(a,7));
		WriteText(hFileHandle, nIOResult, result);         // write 'sMessageToWrite' to the file
		//WriteByte(hFileHandle, nIOResult, CR);                      // write 'CR' to the file (carriage return)
		//WriteByte(hFileHandle, nIOResult, LF);                      // write 'LF' to the file (line feed)
	}
	Close(hFileHandle, nIOResult);                              // close our file (DON'T FORGET THIS STEP!)
}
*/
