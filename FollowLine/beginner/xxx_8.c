#pragma config(Sensor, S1,     sLightRight,    sensorI2CCustom9V)
#pragma config(Sensor, S3,     sTouch,         sensorTouch)
#pragma config(Sensor, S4,     sLightLeft,     sensorI2CCustom9V)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

// time: 	13:20
// motors: 	4
// ger: 	1:1.67


#define RELEASE
#define DEBUG//

int getRWRight();
int getRWLeft();
void calibrate ();
void waitTouchRelease();
//-------------------
float const KL0 = 1.00;
float const KL1 = 1.20;
float const KL2 = 1.40;
float const KL3 = 1.70;
float const KL4 = 2.10;
float const KL5 = 2.60;
float const KL6 = 5.00;
float const KL7 = 7.00;
//--------------------
int  vMax = 100;
float const k = 60;

bool leftAlert  = false;
bool rightAlert = false;

//--------------------

//task speedUp()
//{
//	for(int i = 1 ; i <= 20 ; i++)
//	{
//  vMax++;
//  sleep(50);
//	}
//}

task main()
{

	LLinit(sLightLeft); 	// Set up Line Leader sensor type
	LLinit(sLightRight); 	// Set up Line Leader sensor type

	calibrate();
	waitTouchRelease();

	//startTask(speedUp);

	int e       	= 0;
	int eOld 			= e;
	int rwLeft  	= getRWLeft();
	int rwRight 	= getRWRight();
	int es 				= rwLeft - rwRight;
	float i 				= 0;
	int 	v 				= 0 ;
	int const maxI	= 10;
	int const vMin	= 25;
	int vLeft 			= 0;
	int vRight 			= 0;

	leftAlert  			= false;
  rightAlert 			= false;

	while(true)
	{

		rwLeft = getRWLeft();
		rwRight = getRWRight();

		e = rwLeft - rwRight - es;

		i = i + e / 5000;
		if ( fabs(i) > maxI ) i = sgn(i) * maxI ;

		int u = (e * 1  + (e - eOld ) * 6) ; //+ i ;

		eOld = e ;

		v = (vMax - abs (u) * 0.5); //* SensorValue(sThird) /  InitialValueWhite ;

		if (leftAlert)
		{
			playSound(soundBlip);
			vLeft  = 30 ;
			vRight = 95 ;
		}
		else if (rightAlert)
		{
			playSound(soundBlip);
			vLeft  = 95 ;
			vRight = 30 ;
		}
		else
		{
			vLeft = v + u  ;
			vRight = v - u ;
		}

		if (vLeft < vMin) vLeft = vMin;
		if (vRight < vMin) vRight = vMin;


#ifdef RELEASE
		motor[mLeft] = vLeft;
		motor[mRight] = vRight;
#endif
#ifdef DEBUG
		displayVariableValues(0,rwLeft);
		displayVariableValues(1,rwRight);
		displayVariableValues(3,u);
		displayVariableValues(4,vLeft);
		displayVariableValues(5, vRight);
#endif
		sleep (10);
		if (SensorValue(sTouch)== 1) break;
	}
	LLsleep(sLightLeft); // Sleep to conserve power when not in use
	LLsleep(sLightRight); // Sleep to conserve power when not in use
}

//---------------------------------

void calibrate ()
{
	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}

	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}
	LLcalWhite(sLightLeft);
	LLcalWhite(sLightRight);

	//InitialValueWhite = SensorValue(sThird);

	playSound(soundBlip);

	sleep(1000);

	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}
	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}
	LLcalBlack(sLightLeft);
	LLcalBlack(sLightRight);

	playSound(soundBlip);

	sleep(1000);
}

//-------------------------------

void waitTouchRelease()
{
	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}

	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}

}
//---------------

int getRWLeft()
{
	tByteArray rawLight;
	LLreadSensorRaw(sLightLeft, rawLight);
	leftAlert = leftAlert || (( rawLight[7] < 10 ) && ( rawLight[3] > 10 ));
	leftAlert = leftAlert && ( rawLight[5] > 10 );
	int r =
	(
	rawLight[0]  * KL0 +
	rawLight[1]  * KL1 +
	rawLight[2]  * KL2 +
	rawLight[3]  * KL3 +
	rawLight[4]  * KL4 +
	rawLight[5]  * KL5 +
	rawLight[6]  * KL6 +
	rawLight[7]  * KL7
	) / k;
	if (( rawLight[7] < 10 ) && ( rawLight[0] > 10 )) r = r * -1;
	return r;
}

int getRWRight()
{
	tByteArray rawLight;
	LLreadSensorRaw(sLightRight, rawLight);
	rightAlert = rightAlert || (( rawLight[0] < 10 ) && ( rawLight[4] > 10 ));
	rightAlert = rightAlert && ( rawLight[2] > 10 );
	int r =
	(
	rawLight[0] * KL7 +
	rawLight[1] * KL6 +
	rawLight[2] * KL5 +
	rawLight[3] * KL4 +
	rawLight[4] * KL3 +
	rawLight[5] * KL2 +
	rawLight[6] * KL1 +
	rawLight[7] * KL0
	) / k ;
	if (( rawLight[0] < 10 ) && ( rawLight[7] > 10 )) r = r * -1;
	return r;
}
