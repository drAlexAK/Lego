#pragma config(Sensor, S4,     sFront,         sensorSONAR)
#pragma config(Sensor, S2,     sFrontRight,    sensorI2CCustomFastSkipStates9V))
#pragma config(Motor,  motorA,          mLeft,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mPl,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//
#include "mindsensors-irdist.h"
//varieblas
int vMax = 60;
int vBase = 50;
int vMin = 0;
int vLeft =50;
int vRight =50;
//
#define DIST_TREE_MIN  20
#define DIST_TREE_MAX  30
#define DIST_FRONT_MIN 15
//function
//int getSpeedByFrontDistance();
void findTrees();
int initDistRight();
//tasks
task controlMotors();
//

task main()
{
	sleep(3000);
	startTask(controlMotors);
	findTrees();
}

/*int getSpeedByFrontDistance()
{
int v = 0;
int	s = SensorValue(sFront);
if ( s > 40 )      v = vMax;
else if ( s > 35 ) v = vMax - 10;
else if ( s > 30 ) v = vMax - 20;
else if ( s > 25 ) v = vMax - 30;
else if ( s > 20 ) v = vMax - 45;
}*/
task controlMotors()
{
	while(1){
		int s =SensorValue(sFront);
		if((s< DIST_FRONT_MIN) && ((vLeft > 0) && (vRight > 0))){
			motor[mLeft] = 0;
			motor[mRight] = 0;
			}else{
			motor[mLeft] = vLeft;
			motor[mRight] = vRight;
		}
	}
}

void findTrees()
{
	vLeft = 0;
	vRight = 0;
	int eNorm = initDistRight();
	if (eNorm < 200) eNorm = 200;
	int e =0;
	int u =0;
	int eOld =e;
	int v =0;

	while(true){
		e = eNorm - MSDISTreadDist(sFrontRight);
		u = (e  + ((e - eOld) * 8)) /5;
		v = vBase - (u*0.5);
		vLeft = v - u;
		vRight = v + u;
		eOld = e;
		if(abs(e) > 100){
			vLeft =0;
			vRight =0;
			playSound(soundBeepBeep);
			sleep(3000);
			eOld =0;
			eNorm = e;
		}
		sleep(10);
	}
}

int initDistRight(){

	int d = MSDISTreadDist(sFrontRight);
	int sum =0;

	for(int i =0; i< 3; i++){
		d = MSDISTreadDist(sFrontRight);
		sum += d;
	}
	return sum / 3;

}
