#pragma config(Sensor, S1,     sLightLeft,     sensorLightActive)
#pragma config(Sensor, S2,     sLightCenter,   sensorLightActive)
#pragma config(Sensor, S3,     sLightRight,    sensorLightActive)
#pragma config(Sensor, S4,     sTouch,         sensorTouch)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
//
// struct
typedef struct{
	int left;
	int right;
	int center;
} LightSensors;
//
//
// headers
//
void getLightSensorsValuesByTouch(string *areaDecription, LightSensors &ls);
void WaitTouchSensor();
void ResetLightsSensors();
//
task main()
{

	LightSensors lsWhite;
	LightSensors lsBlack;

	ResetLightsSensors();
	getLightSensorsValuesByTouch("white", lsWhite);
	getLightSensorsValuesByTouch("black", lsBlack);

	WaitTouchSensor();
	eraseDisplay();

	const int minSpeed = 30;
	const int maxSpeed = 70;
	int es = lsWhite.left - lsWhite.right; // error static, different beetwen left and right light sensors at start
	int eOld = 0;
	int v = maxSpeed; // speed

	writeDebugStreamLine("Left\tRight\te\teOld\tu\tv");

	while(true)
	{
		int sLeft  = SensorValue(sLightLeft);
		int sRight = SensorValue(sLightRight);
		int sCenter = SensorValue(sLightCenter);

		//if (( lsWhite.left + lsWhite.right + lsWhite.center) - (sLeft + sRight + sCenter) == 0 ) return; // all values of sensors are equals

		int e = sLeft - sRight - es;

		if (((e>0) & (eOld<0)) | ((e<0) & (eOld>0)))
		{
			eOld = 0 ; //drop eOld
		}
		// the best time 8, 33% - falls
		int u = ( e + ( e - eOld) * 10 ) * 1.8 ;

		v = maxSpeed * (lsBlack.center + lsWhite.center) /1.25 / sCenter ;

		writeDebugStreamLine("%d\t%d\t%d\t%d\t%d\t%d", sLeft, sRight, e, eOld, u, v);

		eOld = e;

		nxtDisplayTextLine(1, "e:  %d", e);
		nxtDisplayTextLine(2, "u:  %d", u);
		nxtDisplayTextLine(3, "vL: %d", v+u);
		nxtDisplayTextLine(4, "vR: %d", v-u);

		nxtDisplayTextLine(5, "sL: %d", sLeft);
		nxtDisplayTextLine(6, "sR: %d", sRight);

		motor[mLeft] = v + u;
		motor[mRight] = v - u;

		wait1Msec(1);
	}
}
//
// Reset sensors value
//
void ResetLightsSensors()
{
	SensorValue(sLightLeft)=0;
	SensorValue(sLightRight)=0;
	SensorValue(sLightCenter)=0;
}

///////
//
// waits touch sensonr and
//
void WaitTouchSensor()
{
	eraseDisplay();
	nxtDisplayTextLine(1, "Stay on the line");
	nxtDisplayTextLine(2, "press button");

	while(SensorValue(sTouch) == 0)
	{
		wait1Msec(10);
	}
	eraseDisplay();  // erase the entire NXT LCD display
	nxtDisplayTextLine(1, "Stay on the line");
	nxtDisplayTextLine(2, "release button");
	nxtDisplayTextLine(3, "to start");

	while(SensorValue(sTouch) == 1)
	{
		wait1Msec(1);
	}
}

///////
//
// waits touch sensor and
// returns light sensors values
//
void getLightSensorsValuesByTouch(string *areaDecription, LightSensors &ls)
{
	eraseDisplay(); // cleans NXT display
	nxtDisplayTextLine(1, "Stay at %s area", areaDecription);
	nxtDisplayTextLine(2, "press button");

	while(SensorValue(sTouch) == 0)
	{
		wait1Msec(10);
	}

	eraseDisplay();  // erase the entire NXT LCD display
	nxtDisplayTextLine(1, "Stay at %s area", areaDecription);
	nxtDisplayTextLine(2, "release button");
	nxtDisplayTextLine(3, "to save values");

	while(SensorValue(sTouch) == 1)
	{
		ls.left=SensorValue(sLightLeft);
		ls.right=SensorValue(sLightRight);
		ls.center=SensorValue(sLightCenter);

		nxtDisplayTextLine(4, "Left:   %d", ls.left);
		nxtDisplayTextLine(5, "Right:  %d", ls.right);
		nxtDisplayTextLine(6, "Center: %d", ls.center);
		nxtDisplayTextLine(7, "Diff:   %d", ls.left - ls.right);

		wait1Msec(10);
	}
	PlaySound(soundBeepBeep);
	wait10Msec(100);
}
