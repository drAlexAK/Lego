#pragma config(Sensor, S1,     sSonarLeft,     sensorSONAR)
#pragma config(Sensor, S2,     sSonarRight,    sensorSONAR)
#pragma config(Sensor, S3,     sTouch,         sensorTouch)
#pragma config(Sensor, S4,     sLight,         sensorI2CCustom9V)
#pragma config(Motor,  motorA,          mShLeft,       tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

bool IsHereBlack();
int GetLightAverage();

task main()
{
	//-----------------------------------------------------
	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}
	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}
	//-----------------------------------------------------
	const int sonarDistance  = 67;
	const int catchDistance  = 30; // 24
	bool target 						 = false;
	int sonarLeft 					 = 0;				// current left sonar sensor
	int sonarRight 					 = 0;				// current left sonar sensor
	SensorValue(sSonarLeft)	 = 0;				// init left sonar sensor
	SensorValue(sSonarRight) = 0;				// init right sonar sensor
	//-----------------------------------------------------

	// Initit motors
	//-----------------------------------------------------
	int vLeft 	= 75;					// left motor power
	int vRight 	= 100;					// right motor power

	motor[mLeft]  = vLeft;					// go ahead
	motor[mRight] = vRight;					// go ahead
	//-----------------------------------------------------
	int sensor = LLreadResult(sLight);
	IsHereBlack();
	while (true)
	{
		// Get light sensor value and turn when current value less or more than start value
		//-----------------------------------------------------
		if ( GetLightAverage()< 15 ) // U turn
		{
			target = false;

			motor[mLeft]  = -100; 		// move back
			motor[mRight] = -100;		  // move back

			sleep(750);

			motor[mLeft]  =  50;		  // turn
			motor[mRight] = -50;		  // turn

			sleep(350);

		}
		//-----------------------------------------------------

		if ( target==true ) continue ; // ignore all sensors because target is true

		// use sonar sensor here
		//-----------------------------------------------------
		sonarLeft  = SensorValue(sSonarLeft);
		sonarRight = SensorValue(sSonarRight);

		if ( sonarLeft  < 5 ) sonarLeft  = 255; // protects from stupid sonar issue when value is 0
			if ( sonarRight < 5 ) sonarRight = 255; // protects from stupid sonar issue when value is 0

		if ( sonarLeft < sonarDistance ) // see on the left
		{
			if ( sonarRight < sonarDistance ) // see on the right too. Go ahead
			{
				if (( sonarLeft < catchDistance ) && ( sonarRight < catchDistance ))
				{
					target = true;
					vLeft  = 100 ;
					vRight = 100 ;
				}
				else
				{

					vLeft  = 100 * sonarLeft / sonarRight ;
					vRight = 100 * sonarRight / sonarLeft ;
				}
			}
			else // see only left only. Turn left
			{
				vLeft  =  22;
				vRight = -15;
			}
		}
		else
		{
			if ( sonarRight < sonarDistance ) // see on the right only. Turn right
			{
				vLeft  = -15;
				vRight =  22;
			}
			else
			{
				vLeft 	= 75;					// left motor power
				vRight 	= 100;					// right motor power
			}
		}

		// sets motors power value
		motor[mLeft]  = vLeft;
		motor[mRight] = vRight;
		sleep(1);
		if (SensorValue(sTouch)== 1) break;
	}
}

// returns true when value of anysensor less than 50
bool IsHereBlack()
{
	tByteArray signalstr;
	LLreadSensorRaw(sLight, signalstr); // read the raw sensor data (8 bit data)

	for (int i = 0 ; i < 8; i++)
	{
		if ( signalstr[i] < 15 ) return true;
	}
	return false;
}

// retruns light average from 0 - black to 100 - white
int GetLightAverage()
{
	int average = 0;
	//int sensor = LLreadResult(sLight); // fetch the data from the sensor
	tByteArray signalstr;

	LLreadSensorRaw(sLight, signalstr); // read the raw sensor data (8 bit data)

	for (int i = 0 ; i<8; i++)
	{
		average += signalstr[i];
	}
	average /= 8;
	return average;
}
