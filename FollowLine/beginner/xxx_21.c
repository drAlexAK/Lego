#pragma config(Sensor, S2,     sLightRight,    sensorI2CCustom9V)
#pragma config(Sensor, S3,     sTouch,         sensorTouch)
#pragma config(Sensor, S4,     sLightLeft,     sensorI2CCustom9V)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

// time: 	10:80 (5:1 round unstable)
// motors: 	4
// ger: 	1:1.67

#define RELEASE
#define DEBUG

int getRWRight();
int getRWLeft();
void calibrate ();
void waitTouchRelease();
//-------------------
float const KL0 = 1.00;
float const KL1 = 1.00;
float const KL2 = 1.00;
float const KL3 = 1.00;
float const KL4 = 1.00;
float const KL5 = 1.00;
float const KL6 = 1.00;
float const KL7 = 1.00;
//--------------------
int vBase 			= 95;
int const vMin	= 15;
int const maxI	= 5;
float const k 	= 33;
int iAlert			= 0;
bool leftAlert  = false;
bool rightAlert = false;
//--------------------
task speedUp()
{
	int vFinish        = vBase;
	int const vStart   = 30;
	int const tSpeedUp = 350;
	int tSleep = tSpeedUp / ( vFinish - vStart );

	for ( int i = vStart ; i <= vFinish ; i++ )
	{
		vBase = i ;
		sleep(tSleep);
	}
}

//--------------------
task main()
{

	LLinit(sLightLeft); 	// Set up Line Leader sensor type
	LLinit(sLightRight); 	// Set up Line Leader sensor type

	calibrate();
	waitTouchRelease();
	startTask(speedUp);

	int e       		= 0;
	int eOld 				= e;
	int rwLeft  		= getRWLeft();
	int rwRight 		= getRWRight();
	int es 					= rwLeft - rwRight;
	float i 				= 0;
	int 	v 				= 0 ;
	int   u					= 0 ;
	int vLeft 			= 0;
	int vRight 			= 0;

	leftAlert  			= false;
	rightAlert 			= false;

	float g =0;

	while(true)
	{
		rwLeft  = getRWLeft();
		rwRight = getRWRight();

		e = rwLeft - rwRight - es;

		if (abs(e)<100)
		{
			g=5;
		}
		else
		{
			g = abs(e)/1400;
			g=g*g*g;
		}
		if (leftAlert)
		{
			if ( iAlert == 0 ) playSound(soundBlip);
			vLeft  = 20;//vLeft  - g ;
			vRight = 90 ;
			iAlert ++;
		}
		else if (rightAlert)
		{
			if ( iAlert == 0 ) playSound(soundBlip);
			vLeft  = 90;
			vRight = 20; //vRight - g;
			iAlert ++;
		}
		else
		{
			if ( iAlert != 0 )
			{
				playSound(soundBlip);
				i=0;
			}
			i = i + e / 5000;
			if ( fabs(i) > maxI ) i = sgn(i) * maxI ;
			u = (e * 1  + (e - eOld ) * 6) / k + i ;
			v = (vBase - abs (u) * 0.75) ;
			vLeft  = v + u  ;
			vRight = v - u ;
			iAlert = 0;
		}

		eOld = e ;

		if (vLeft  < vMin) vLeft  = vMin;
		if (vRight < vMin) vRight = vMin;
		if (vLeft  > 100)  vLeft  = 100;
		if (vRight > 100)  vRight = 100;

#ifdef RELEASE
		//motor[mLeft]  = (motor[mLeft]  + vLeft )/2;
		//motor[mRight] = (motor[mRight] + vRight)/2;
		motor[mLeft]  = vLeft;
		motor[mRight] = vRight;
#endif
#ifdef DEBUG
		displayVariableValues(0,rwLeft);
		displayVariableValues(1,rwRight);
		displayVariableValues(2,leftAlert);
		displayVariableValues(3,rightAlert);
		displayVariableValues(4,e);
		displayVariableValues(5,u);
		displayVariableValues(6,vLeft);
		displayVariableValues(7, vRight);
#endif
		sleep (10);
		if (SensorValue(sTouch) == 1) break;
	}
	LLsleep(sLightLeft);  // Sleep to conserve power when not in use
	LLsleep(sLightRight); // Sleep to conserve power when not in use
}

//---------------------------------

void calibrate ()
{
	while (SensorValue(sTouch) == 0)
	{
		sleep (10);
	}

	while (SensorValue(sTouch) == 1)
	{
		sleep (10);
	}
	LLcalWhite(sLightLeft);
	LLcalWhite(sLightRight);

	playSound(soundBlip);

	sleep(1000);

	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}
	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}
	LLcalBlack(sLightLeft);
	LLcalBlack(sLightRight);

	playSound(soundBlip);

	sleep(1000);
}

//-------------------------------

void waitTouchRelease()
{
	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}

	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}

}
//---------------
int getRWLeft()
{
	tByteArray rawLight;
	LLreadSensorRaw(sLightLeft, rawLight);

	if (( rawLight[7] < 20 ) && (( rawLight[4] > 40) || ( rawLight[3] > 40) || ( rawLight[2] > 40) || ( rawLight[1] > 40) || ( rawLight[0] > 40))) leftAlert = true ;
	if ( leftAlert && ( iAlert > 1 )) leftAlert = (( rawLight[4] > 20 ) && ( rawLight[3] > 20 ) && ( rawLight[1] > 20 ) && ( rawLight[0] > 20 )) ;
	//if ( leftAlert && ( iAlert > 0 )) leftAlert = ! (( rawLight[7] > 40 ) && ( rawLight[0] < 40 ))  ;

	if ( leftAlert ) rightAlert = false;

	int r =
	(
	rawLight[0]  * KL0 +
	rawLight[1]  * KL1 +
	rawLight[2]  * KL2 +
	rawLight[3]  * KL3 +
	rawLight[4]  * KL4 +
	rawLight[5]  * KL5 +
	rawLight[6]  * KL6 +
	rawLight[7]  * KL7
	) ;
	//if (r < 720 ) rightAlert = false;
	if (( rawLight[7] < 10 ) && ( rawLight[0] > 10 )) r = r * -1;
	return r;
}
//--------------------
int getRWRight()
{
	tByteArray rawLight;
	LLreadSensorRaw(sLightRight, rawLight);

	if (( rawLight[0] < 20 ) && (( rawLight[5] > 40 ) || ( rawLight[4] > 40 ) || ( rawLight[5] > 40 ) || ( rawLight[6] > 40 ) || ( rawLight[7] > 40 ))) rightAlert = true;
	if ( rightAlert && ( iAlert > 1 )) rightAlert =	((rawLight[3] > 20 ) && (rawLight[4] > 20 ) && (rawLight[5] > 20 ) && ( rawLight[6] > 20 ) && ( rawLight[7] > 20 ));
	// if ( rightAlert && ( iAlert > 0 )) rightAlert =	! (( rawLight[0] > 40 ) && ( rawLight[7] < 40 ));

	if ( rightAlert ) leftAlert = false;

	int r =
	(
	rawLight[0] * KL7 +
	rawLight[1] * KL6 +
	rawLight[2] * KL5 +
	rawLight[3] * KL4 +
	rawLight[4] * KL3 +
	rawLight[5] * KL2 +
	rawLight[6] * KL1 +
	rawLight[7] * KL0
	) ;
	//if (r < 720 ) leftAlert = false;
	if (( rawLight[0] < 10 ) && ( rawLight[7] > 10 )) r = r * -1;
	return r;
}
